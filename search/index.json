[{"content":"The December release of Tabby CAD Suite is now available for download. Notable changes in this version include:\nWe have improved support for SystemVerilog config elements. You can now have multiple configurations defined, and select which configuration to elaborate with verific -import \u0026lt;configname\u0026gt;. We are working on improving the TCL integration in Yosys. There is now an interactive TCL shell mode: use yosys -C to enter the TCL shell. You can now also use the following command to get the output of a command returned to TCL without the use of an intermediate file: set command_output [yosys tee -s result.string \u0026lt;command\u0026gt;] In other YosysHQ news We had another great guest blogpost from Tom Verbeure. He wrote about how Yosys does techmapping, in particular logic primitive transformations. If you’ve not read any of Tom’s other writing, he has a very interesting index here. Two of our favourites are Post-Simulation Waveform-Based RISC-V with GDB and Cosimulating Verilog and VHDL with CXXRTL. We are starting a ‘community spotlight’ feature to help highlight useful open source EDA tools. If you have a tip, please let us know. ","date":"2022-12-12T00:00:00Z","image":"http://blog.yosyshq.com/static-2022/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20221205-released/","title":"Tabby CAD Suite version 20221205 released!"},{"content":"This guest post is by Tom Verbeure.\nIntroduction If you\u0026rsquo;re reading this you probably already know that Yosys is an open source logic synthesis tool. You may also know that it\u0026rsquo;s much more than that: in my earlier blog post about CXXRTL I call it the swiss army knife of digital logic manipulation.\nIn most cases, using Yosys means running pre-made scripts that contain Yosys commands: when I\u0026rsquo;m synthesizing RTL for an FPGA of the Lattice iCE40 family, the synth_ice40 command is usually sufficient to convert my RTL into a netlist that can be sent straight to nextpnr for place, route, and bitstream creation.\nMy current version of Yosys has 232 commands, and many of these commands have an impressive list of additional options, but sometimes you want to perform very particular logic operations that don\u0026rsquo;t come standard with the tool.\nIn this blog post, I\u0026rsquo;ll talk about the techmap command, a particularly powerful command that allows one to make custom logic transformations by replacing a logic cell instance of a given type to one or more different ones.\nMapping a multiplication to an FPGA DSP Cell There is a companion yosys_techmap_blog project on GitHub that contains the Verilog source files and the scripts to generate the graphics and Yosys results of this blog post.\nA good example of a techmap operation is one where a generic multipication is converted into a DSP block of an FPGA. For those who are unfamiliar with the technology, FPGAs usually have only a few core logic primitives: lookup-table cells (LUTs) are used to construct any kind of random logic circuit, RAM cells are, well, RAMs, and DSPs are larger cells that contain one or more hardware multipliers, often in combination with an accumulator.\nLet\u0026rsquo;s look at this Verilog module, mul.v, that multiplies two 10-bit values into a 20-bit result:\nmodule top(input [9:0] op0, input [9:0] op1, output [19:0] result); assign result = op0 * op1; endmodule When reading in the Verilog file, Yosys translates it into RTLIL (RTL Internal Language), the internal representation of the design. The multiplication operation becomes a $mul primitive, and the whole design looks like this:\nmodule \\top wire width 10 input 1 \\op0 wire width 10 input 2 \\op1 wire width 20 output 3 \\result cell $mul $mul$mul.v:3$1 parameter \\A_SIGNED 0 parameter \\A_WIDTH 10 parameter \\B_SIGNED 0 parameter \\B_WIDTH 10 parameter \\Y_WIDTH 20 connect \\A \\op0 connect \\B \\op1 connect \\Y \\result end Yosys has the super useful show command that renders an RTLIL representation as a graph. I usually add the -width -signed options to annotate signals with their size and to show which cell ports are signed:\nThis primitive must be converted into cells of the target technology. Most FPGAs from the iCE40 family have a handful of DSPs. When you synthesize this module to the iCE40 technology with synth_ice40 -dsp, the $mul primitive gets converted to an SB_MAC16 cell which is the DSP primitive of the iCE40 family.\nThe SB_MAC16 DSP has a ton of data path and configuration signals, and the multiplier inputs and output can be up to 16 and 32-bits wide respectively. It\u0026rsquo;s up to a techmap step to assign all the right values to the configuration signals, and to correctly tie down unused input data bits or ignore excess output bits so that the DSP performs the desired 10-bit x 10-bit multiplication.\nAfter cleaning up some irrelevant cruft, the post-synthesis RTLIL looks like this:\nmodule \\top wire width 10 input 1 \\op0 wire width 10 input 2 \\op1 wire width 20 output 3 \\result wire \\result_SB_MAC16_O_ACCUMCO wire \\result_SB_MAC16_O_CO wire width 12 \\result_SB_MAC16_O_O wire \\result_SB_MAC16_O_SIGNEXTOUT cell \\SB_MAC16 \\result_SB_MAC16_O parameter \\A_REG 1\u0026#39;0 parameter \\A_SIGNED 0 parameter \\BOTADDSUB_CARRYSELECT 2\u0026#39;00 parameter \\BOTADDSUB_LOWERINPUT 2\u0026#39;10 parameter \\BOTADDSUB_UPPERINPUT 1\u0026#39;1 parameter \\BOTOUTPUT_SELECT 2\u0026#39;11 parameter \\BOT_8x8_MULT_REG 1\u0026#39;0 parameter \\B_REG 1\u0026#39;0 parameter \\B_SIGNED 0 parameter \\C_REG 1\u0026#39;0 parameter \\D_REG 1\u0026#39;0 parameter \\MODE_8x8 1\u0026#39;0 parameter \\NEG_TRIGGER 1\u0026#39;0 parameter \\PIPELINE_16x16_MULT_REG1 1\u0026#39;0 parameter \\PIPELINE_16x16_MULT_REG2 1\u0026#39;0 parameter \\TOPADDSUB_CARRYSELECT 2\u0026#39;11 parameter \\TOPADDSUB_LOWERINPUT 2\u0026#39;10 parameter \\TOPADDSUB_UPPERINPUT 1\u0026#39;1 parameter \\TOPOUTPUT_SELECT 2\u0026#39;11 parameter \\TOP_8x8_MULT_REG 1\u0026#39;0 connect \\A { 6\u0026#39;000000 \\op0 } connect \\ACCUMCI 1\u0026#39;x connect \\ACCUMCO \\result_SB_MAC16_O_ACCUMCO connect \\ADDSUBBOT 1\u0026#39;0 connect \\ADDSUBTOP 1\u0026#39;0 connect \\AHOLD 1\u0026#39;0 connect \\B { 6\u0026#39;000000 \\op1 } connect \\BHOLD 1\u0026#39;0 connect \\C 16\u0026#39;0000000000000000 connect \\CE 1\u0026#39;0 connect \\CHOLD 1\u0026#39;0 connect \\CI 1\u0026#39;x connect \\CLK 1\u0026#39;0 connect \\CO \\result_SB_MAC16_O_CO connect \\D 16\u0026#39;0000000000000000 connect \\DHOLD 1\u0026#39;0 connect \\IRSTBOT 1\u0026#39;0 connect \\IRSTTOP 1\u0026#39;0 connect \\O { \\result_SB_MAC16_O_O \\result } connect \\OHOLDBOT 1\u0026#39;0 connect \\OHOLDTOP 1\u0026#39;0 connect \\OLOADBOT 1\u0026#39;0 connect \\OLOADTOP 1\u0026#39;0 connect \\ORSTBOT 1\u0026#39;0 connect \\ORSTTOP 1\u0026#39;0 connect \\SIGNEXTIN 1\u0026#39;x connect \\SIGNEXTOUT \\result_SB_MAC16_O_SIGNEXTOUT end end And here\u0026rsquo;s the equivalent graphical representation. (Click to enlarge)\nAll Yosys commands are written in C++, but in the case of techmap the specific mapping operations are described in\u0026hellip; Verilog! It\u0026rsquo;s a very neat system that makes it possible for anyone to create their own custom mapping operations without the need to touch a line of C++.\nLet\u0026rsquo;s see exactly how that works for our example, and look at the source code of the synth_ice40 command.\nYosys places all the technology-specific operations under the techlibs directory. The code for synth_ice40 can be found in techlibs/ice40/synth_ice40.cc. synth_ice40 doesn\u0026rsquo;t really have any smarts by itself: it\u0026rsquo;s a macro command, a series of lower level Yosys commands strung together into a recipe.\nWhen you run help synth_ice40 in Yosys, you\u0026rsquo;ll see the following command line option:\n-dsp use iCE40 UltraPlus DSP cells for large arithmetic It\u0026rsquo;s easy to see which steps are activated in the source code when DSP mapping is enabled:\nrun(\u0026#34;memory_dff\u0026#34; + no_rw_check_opt); // ice40_dsp will merge registers, reserve memory port registers first run(\u0026#34;wreduce t:$mul\u0026#34;); run(\u0026#34;techmap -map +/mul2dsp.v -map +/ice40/dsp_map.v -D DSP_A_MAXWIDTH=16 -D DSP_B_MAXWIDTH=16 \u0026#34; \u0026#34;-D DSP_A_MINWIDTH=2 -D DSP_B_MINWIDTH=2 -D DSP_Y_MINWIDTH=11 \u0026#34; \u0026#34;-D DSP_NAME=$__MUL16X16\u0026#34;, \u0026#34;(if -dsp)\u0026#34;); run(\u0026#34;select a:mul2dsp\u0026#34;, \u0026#34; (if -dsp)\u0026#34;); run(\u0026#34;setattr -unset mul2dsp\u0026#34;, \u0026#34; (if -dsp)\u0026#34;); run(\u0026#34;opt_expr -fine\u0026#34;, \u0026#34; (if -dsp)\u0026#34;); run(\u0026#34;wreduce\u0026#34;, \u0026#34; (if -dsp)\u0026#34;); run(\u0026#34;select -clear\u0026#34;, \u0026#34; (if -dsp)\u0026#34;); run(\u0026#34;ice40_dsp\u0026#34;, \u0026#34; (if -dsp)\u0026#34;); run(\u0026#34;chtype -set $mul t:$__soft_mul\u0026#34;, \u0026#34;(if -dsp)\u0026#34;); There\u0026rsquo;s quite a bit going on here, but the most interesting command is this one:\ntechmap -map +/mul2dsp.v -map +/ice40/dsp_map.v -D DSP_A_MAXWIDTH=16 -D DSP_B_MAXWIDTH=16 -D DSP_A_MINWIDTH=2 -D DSP_B_MINWIDTH=2 -D DSP_Y_MINWIDTH=11 -D DSP_NAME=$__MUL16X16 What we see here is that techmap is performing the $mul to SB_MAC16 conversion in two steps:\nconvert $mul to a generic, technology independent DSP multiplier cell. convert the generic multiplier DSP cell to an iCE40 DSP cell. Step 1: mul2dsp.v\nStep 1 is done by mul2dsp.v. The code is a bit convoluted, but it has the answer as to why there\u0026rsquo;s this intermediate step:\nit deals with cases where a single $mul operation requires more than one DSP.\nFor example, a 32-bit x 32-bit to 64-bit multiplication is split into 4 16x16=32 multiplications and some additions.\nit doesn\u0026rsquo;t do the conversion when the inputs of the multiplication are too small\nThis avoids wasting precious DSP resources on something that can be implemented with core logic.\nThe -D ... arguments of the techmap command specify Verilog defines that are passed to the techmap file. It\u0026rsquo;s used to parameterize the conversion process:\n-D DSP_A_MAXWIDTH=16 -D DSP_B_MAXWIDTH=16 informs mul2dsp that the maximum input size of the DSP is 16 bits. -D DSP_A_MINWIDTH=2 -D DSP_B_MINWIDTH=2 -D DSP_Y_MINWIDTH=11 provides the minimum requirements that must be satisfied to do the conversion. -D DSP_NAME=$__MUL16X16 provides the name of the generic multiplier cells that should be created. We can run that first step by ourselves and check the result:\nread_verilog mul.v clean -purge techmap -map +/mul2dsp.v -D DSP_A_MAXWIDTH=16 -D DSP_B_MAXWIDTH=16 -D DSP_A_MINWIDTH=2 -D DSP_B_MINWIDTH=2 -D DSP_Y_MINWIDTH=11 -D DSP_NAME=$__MUL16X16 clean -purge show -width -signed -format png -prefix mul_mul2dsp In case you were wondering, here\u0026rsquo;s what this first step looks like for a 20-bit x 20-bit to 40-bit multiplier:\n(Click to enlarge)\nYosys can often create very long internal labels that stretch the graphical representation, so I zoomed the image to the part that counts. The 3 red rectangles are the $__MUL16X16 cells that will be converted to iCE40 DSPs. The blue rectangle is a $__soft_mul cell that will be converted into random logic at a large stage, and the 3 green rectangles are $add cells to bring the results of the different multipliers together.\nStep 2: ice40/dsp_map.v\nStep 2 of the techmap process, ice40/dsp_map.v is trivial: it converts the generic $__MUL16X16 multiplier cell into an SB_MAC16 cell, wires up the data path inputs and output, and straps all the other configuration inputs so that the cell is configured as a straight multiplier.\nmodule \\$__MUL16X16 (input [15:0] A, input [15:0] B, output [31:0] Y); parameter A_SIGNED = 0; parameter B_SIGNED = 0; parameter A_WIDTH = 0; parameter B_WIDTH = 0; parameter Y_WIDTH = 0; SB_MAC16 #( .NEG_TRIGGER(1\u0026#39;b0), .C_REG(1\u0026#39;b0), .A_REG(1\u0026#39;b0), .B_REG(1\u0026#39;b0), .D_REG(1\u0026#39;b0), .TOP_8x8_MULT_REG(1\u0026#39;b0), .BOT_8x8_MULT_REG(1\u0026#39;b0), .PIPELINE_16x16_MULT_REG1(1\u0026#39;b0), .PIPELINE_16x16_MULT_REG2(1\u0026#39;b0), .TOPOUTPUT_SELECT(2\u0026#39;b11), .TOPADDSUB_LOWERINPUT(2\u0026#39;b0), .TOPADDSUB_UPPERINPUT(1\u0026#39;b0), .TOPADDSUB_CARRYSELECT(2\u0026#39;b0), .BOTOUTPUT_SELECT(2\u0026#39;b11), .BOTADDSUB_LOWERINPUT(2\u0026#39;b0), .BOTADDSUB_UPPERINPUT(1\u0026#39;b0), .BOTADDSUB_CARRYSELECT(2\u0026#39;b0), .MODE_8x8(1\u0026#39;b0), .A_SIGNED(A_SIGNED), .B_SIGNED(B_SIGNED) ) _TECHMAP_REPLACE_ ( .A(A), .B(B), .O(Y), ); endmodule A Horribly Contrived Example Problem Have a look at the following Verilog example code:\nmodule top_unsigned(input [5:0] op0, input [6:0] op1, output [63:0] sum); assign sum = op0 + op1; endmodule The graphical representation is as expected:\nI sometimes use CXXRTL to simulate my designs. When I run write_cxxrtl, the generated file contains the following:\nbool p_top__unsigned::eval() { bool converged = true; p_sum0 = add_uu\u0026lt;64\u0026gt;(p_op0, p_op1); return converged; } This is exactly as expected, and there\u0026rsquo;s nothing wrong with it. But one thing that bothers me is that CXXRTL uses 32-bit integer values (\u0026ldquo;chunks\u0026rdquo;) for all its operations. In the code above, there\u0026rsquo;s a 64-bit addition, and CXXRTL implements those by splitting things up into multiple 32-bit additions:\ntemplate\u0026lt;bool Invert, bool CarryIn\u0026gt; std::pair\u0026lt;value\u0026lt;Bits\u0026gt;, bool /*CarryOut*/\u0026gt; alu(const value\u0026lt;Bits\u0026gt; \u0026amp;other) const { value\u0026lt;Bits\u0026gt; result; bool carry = CarryIn; for (size_t n = 0; n \u0026lt; result.chunks; n++) { result.data[n] = data[n] + (Invert ? ~other.data[n] : other.data[n]) + carry; if (result.chunks - 1 == n) result.data[result.chunks - 1] \u0026amp;= result.msb_mask; carry = (result.data[n] \u0026lt; data[n]) || (result.data[n] == data[n] \u0026amp;\u0026amp; carry); } return {result, carry}; } It\u0026rsquo;s a hand-crafted carry-ripple adder. Now, don\u0026rsquo;t worry, things are really not as bad as it seems, because all the variables that are used for the if conditionals and the for loop are constants. Any good C++ compiler will optimize the addition above into only a few assembler instructions.\nIf you know your binary adder basics, you see that the addition of a 7-bit and a 6 bit operand will result at most in an 8-bit result. All higher bits will always be 0. It\u0026rsquo;s overkill to have a 64-bit adder.\nYosys already has the wreduce command that reduces logic operations to just the number of bits that are really needed.\nWe can see this when we run the following commands:\nread_verilog add.v hierarchy -top top_unsigned wreduce clean -purge And here\u0026rsquo;s the relevant CXXRTL generated code:\nbool p_top__unsigned::eval() { bool converged = true; p_sum0.slice\u0026lt;7,0\u0026gt;() = add_uu\u0026lt;8\u0026gt;(p_op0, p_op1); p_sum0.slice\u0026lt;63,8\u0026gt;() = value\u0026lt;56\u0026gt;{0u,0u}; return converged; } That looks better, but is that really true? The addition returns an 8-bit value, but since the smallest chunk is 32-bits, the slice\u0026lt;7,0\u0026gt; command now requires a read-modify-write operation.\nWhat I really want is this:\nbool p_top__unsigned::eval() { bool converged = true; p_sum0.slice\u0026lt;31,0\u0026gt;() = add_uu\u0026lt;32\u0026gt;(p_op0, p_op1); \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; 32 bits p_sum0.slice\u0026lt;63,32\u0026gt;() = value\u0026lt;32\u0026gt;{0u,0u};\t\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; 32 bits return converged; } Unfortunately, Yosys doesn\u0026rsquo;t have a command that does this for me, and I really don\u0026rsquo;t want to modify the C++ code of the wreduce command to make it so.\nA Custom Techmap Transformation to the Rescue! If you start Yosys, running help techmap will give you an exhaustive list of all the features that you might ever need. But instead of repeating everything in there, let\u0026rsquo;s create an add_reduce techmap transformation to solve the problem of the previous section.\nHere are some of the basics of a techmap transformation Verilog module:\na techmap transformation only operates on a single design cell.\nYou can not use techmap to perform multi-cell optimizations such mapping a $mul followed by an $add onto an FPGA DSP has multiply-accumulator support.\na design cell that is transformed by a techmap is selected by a string that contains a list of cell types that are specified with the (* techmap_celltype \u0026quot;...\u0026quot;) attribute. If the techmap module doesn\u0026rsquo;t have such an attribute, then it\u0026rsquo;s determined by the name of the Verilog module.\nby default, a techmap operation will iterate on itself until there\u0026rsquo;s nothing left that matches.\nIf a techmap operation replaces an $add primitive by a new $add primitive, techmap will run again on the second one. Without some kind of abort mechanism, this will result in an endless loop!\nThere are multiple ways to avoid such an endless loop though. I\u0026rsquo;ll get to that later.\nit\u0026rsquo;s always a good idea to normalize the configuration on which you want to do the main transformation.\nHere\u0026rsquo;s a good example of what I mean by that: we want to reduce the size of an adder based on the size of its inputs. But an adder has 2 inputs, and if these inputs have a different size, then the transformation will have a different code path depending on which input is largest.\nHowever, an addition is commutative: the order of the inputs doesn\u0026rsquo;t matter.\nIt\u0026rsquo;s easier first do a normalization where the A input is guaranteed to be larger or equal than the B input by swapping the inputs, so that actual reduction transformation only has to deal with one case.\nThe earlier discussed mul2dsp techmap module does the same thing.\nThe add_reduce techmap module declaration\nIn this example, I want a transformation that only works on an $add instance, so I could create a techmap Verilog module like this:\nmodule \\$add(A, B, Y); ... But I prefer to use a descriptive name for the module and use the (* techmap_celltype ...) option to select the cell types on which the module operates:\n(* techmap_celltype \u0026#34;$add\u0026#34; *) module add_reduce(A, B, Y); ... The add_reduce techmap module interface\nThe techmap module interface should be the same as the cell on which it operates. Both the input/output signals and the parameters must be the same. Yosys has a Verilog file called simlib.v that contains the reference simulation modules of all its internal primitives. You can use this to check out the interface details of particular primitive.\nHere\u0026rsquo;s the one for the $add primitive\nmodule \\$add (A, B, Y); parameter A_SIGNED = 0; parameter B_SIGNED = 0; parameter A_WIDTH = 0; parameter B_WIDTH = 0; parameter Y_WIDTH = 0; input [A_WIDTH-1:0] A; input [B_WIDTH-1:0] B; output [Y_WIDTH-1:0] Y; The add_reduce techmap module has the same interface:\n(* techmap_celltype = \u0026#34;$add\u0026#34; *) module add_reduce (A, B, Y); parameter A_SIGNED = 0; parameter B_SIGNED = 0; parameter A_WIDTH = 1; parameter B_WIDTH = 1; parameter Y_WIDTH = 1; (* force_downto *) input [A_WIDTH-1:0] A; (* force_downto *) input [B_WIDTH-1:0] B; (* force_downto *) output [Y_WIDTH-1:0] Y; The force_downto attribute ensures that the highest numbered bit of each signal is the MSB. When this attribute is present, Yosys will automatically swap around the bits of connected wires so that you don\u0026rsquo;t need to worry about wackos who use bit 0 as MSB.\nadd_reduce stop conditions\nSince we\u0026rsquo;re replacing an $add primitive with another $add primitive, we need to make sure that there are special conditions to prevent the techmap operation to run forever.\nWe can tell the techmap command to stop transforming the current cell instance by assigning a non-zero value to the _TECHMAP_FAIL_ wire:\nwire _TECHMAP_FAIL_ = 1; For this operation, we want stop transforming an $add primitive for a number of conditions:\nwhen the size of the adder is already equal or smaller than the minimal desired adder.\nWe can set the minimum size with the `Y_MIN_WIDTH define.\nWhen the size of the adder can\u0026rsquo;t be reduced because it would change the result of the calculation.\nWhen it\u0026rsquo;s a signed addition and we only want to transform unsigned additions.\nThe `REDUCE_SIGNED define must be set to allow signed adder transformation.\nThis translates into the following code:\nlocalparam SIGNED_ADDER = (A_SIGNED == 1 \u0026amp;\u0026amp; B_SIGNED == 1); generate if (Y_WIDTH \u0026lt;= `Y_MIN_WIDTH) begin wire _TECHMAP_FAIL_ = 1; end else if (Y_WIDTH \u0026lt;= A_WIDTH+1) begin wire _TECHMAP_FAIL_ = 1; end else if (SIGNED_ADDER \u0026amp;\u0026amp; !`REDUCE_SIGNED) begin wire _TECHMAP_FAIL_ = 1; end ... There are other ways to prevent techmap to run forever. For example, in the mul2dsp.v code, a $__soft_mul cell used instead of a $mul primitive. Yosys has no such primitive, but in a later step, after techmap has been completed, this $__soft_mul cell is converted back to a $mul$ cell:\nchtype -set $mul t:$__soft_mul add_reduce normalization\nThe normalization code of add_reduce is pretty much a straight copy of the one from mul2dsp:\ngenerate ... else if (B_WIDTH \u0026gt; A_WIDTH) begin \\$add #( .A_SIGNED(B_SIGNED), \u0026lt;\u0026lt;\u0026lt; A and B are swapped .B_SIGNED(A_SIGNED), \u0026lt;\u0026lt;\u0026lt; .A_WIDTH(B_WIDTH), \u0026lt;\u0026lt;\u0026lt; .B_WIDTH(A_WIDTH), \u0026lt;\u0026lt;\u0026lt; .Y_WIDTH(Y_WIDTH) ) _TECHMAP_REPLACE_ ( .A(B), \u0026lt;\u0026lt;\u0026lt; .B(A), \u0026lt;\u0026lt;\u0026lt; .Y(Y) ); end else if ... When using _TECHMAP_REPLACE_ as instance name of the swapped $add primitive, it will inherit the instance name of the original instance. This is one of the many predefined variables that are explained by running help techmap in Yosys.\nSince we replace $add with $add, running techmap will result in the $add cell being transformed twice times if B is larger than A: the first time to swap the inputs, and the second time for the actual reduction.\nIf techmap needs to transform the same cell multiple times, it can be hard to debug. You can use the -max_iter \u0026lt;number\u0026gt; option to limit the number of transformations.\nFor example, here\u0026rsquo;s what the design originally looked like:\nAnd here\u0026rsquo;s how things look when stopping the add_reduce operation after the first iteration:\ntechmap -map add_reduce.v -max_iter 1 clean -purge op1 with the largest input size of 7 is now connected to A!\nThe actual add_reduce transformation\nNow that all preliminary formalities are behind use, the actual reduction code is pretty straightfoward:\nelse begin localparam ADDER_WIDTH = `MAX(`Y_MIN_WIDTH, A_WIDTH+1); \\$add #( .A_SIGNED(A_SIGNED), .B_SIGNED(B_SIGNED), .A_WIDTH(A_WIDTH), .B_WIDTH(B_WIDTH), .Y_WIDTH(ADDER_WIDTH) ) _TECHMAP_REPLACE_ ( .A(A), .B(B), .Y(Y[ADDER_WIDTH-1:0]) // Reduced output size ); // Higher bits are 0 or sign extension assign Y[Y_WIDTH-1:ADDER_WIDTH] = { (Y_WIDTH-ADDER_WIDTH){SIGNED_ADDER ? Y[ADDER_WIDTH-1] : 1\u0026#39;b0} }; end The final add_reduce.v code can be found here. We can run the whole thing with:\ntechmap -map add_reduce.v -D Y_MIN_WIDTH=32 clean -purge The result is exactly what we wanted, as shown in the graphical diagram\u0026hellip;\n\u0026hellip;and in the CXXRTL-generated code:\nbool p_top__unsigned::eval() { bool converged = true; p_sum0.slice\u0026lt;31,0\u0026gt;() = add_uu\u0026lt;32\u0026gt;(p_op1, p_op0); p_sum0.slice\u0026lt;63,32\u0026gt;() = value\u0026lt;32\u0026gt;{0u}; return converged; } Formal Equivalence Check Whenever you do logic transformations, it\u0026rsquo;s not a bad idea to check that the pre- and post-transformation logic behaves exactly the same. Yosys has a basic built-in equivalence checker. It\u0026rsquo;s not a performance monster, but it\u0026rsquo;s good enough for this kind of use case.\nIn the example below, I\u0026rsquo;m verifying the add_reduce techmap on a design with an adder that has an output that\u0026rsquo;s 10 instead of 64 bits, and the minimum size is set to 8. This makes the size of the graphs more managable.\n# Load the original design read_verilog add.v hierarchy -top top_unsigned10 rename top_unsigned10 top_unsigned # Make a golden reference copy of the unmodified design copy top_unsigned top_unsigned_gold # Select the original version to do the techmap select top_unsigned # Do the techmap on top_unsigned techmap -map add_reduce.v -D Y_MIN_WIDTH=8 clean -purge So far, so good: Yosys now has 2 designs. top_unsigned_gold is the original one:\nAnd top_unsigned has been transformed with the techmap:\nLet\u0026rsquo;s compare them:\nequiv_make top_unsigned_gold top_unsigned top_equiv select top_equiv The equiv_make has the golden and the transformed design as input and creates a new design with $equiv primitive cells inserted at the output of both designs. These cells will tell the equivalence checker which nets to check for formal equivalence. The new design top_equiv looks like this:\n(Click to enlarge)\nAs you can see, the new design has both the golden and the transformed logic on the left, driven by the same inputs. For there are 10 $equiv cells, one for each bit of the output.\nWe can now run the equivalence check:\nequiv_simple You\u0026rsquo;ll see something like this:\n8. Executing EQUIV_SIMPLE pass. Found 10 unproven $equiv cells (1 groups) in top_equiv: Grouping SAT models for \\sum0: Trying to prove $equiv for \\sum0 [0]: success! Trying to prove $equiv for \\sum0 [1]: success! Trying to prove $equiv for \\sum0 [2]: success! Trying to prove $equiv for \\sum0 [3]: success! Trying to prove $equiv for \\sum0 [4]: success! Trying to prove $equiv for \\sum0 [5]: success! Trying to prove $equiv for \\sum0 [6]: success! Trying to prove $equiv for \\sum0 [7]: success! Trying to prove $equiv for \\sum0 [8]: success! Trying to prove $equiv for \\sum0 [9]: success! Proved 10 previously unproven $equiv cells. Each individual bit has been proven to be correct.\nWe can make Yosys fail if there were any unproven $equiv cells, like this:\nequiv_status -assert However, in our case, all is well:\n9. Executing EQUIV_STATUS pass. Found 10 $equiv cells in top_equiv: Of those cells 10 are proven and 0 are unproven. Equivalence successfully proven! We\u0026rsquo;ve now proven that our add_reduce techmap is correct, but that doesn\u0026rsquo;t mean it\u0026rsquo;s guaranteed bug free: we\u0026rsquo;ve only tested one combination of input and output signal sizes. To be absolutely sure, you\u0026rsquo;d need more variety of test cases.\nThis is only a quick example of what Yosys can do, there\u0026rsquo;s a variety of additional equivalence and logic proof features, most of which I don\u0026rsquo;t know much about! You could start by checking out the help information for the equiv_*, miter, and sat commands to learn more.\nCleaning Up When Yosys creates new cells and reconnects wires, it won\u0026rsquo;t immediately delete older cells and wires that aren\u0026rsquo;t used anymore. You need to expliclity tell Yosys to do so with the clean -purge command that you can see in some of the command sequences above.\nHere\u0026rsquo;s what the reduced adder looks like without first running a clean:\nThat\u0026rsquo;s why you see a clean -purge statement all over the place in the script generates all the pretty pictures of this blog post.\nConclusion Techmap is a very nice tool to have to transform single cells into something that better maps to your chosen target. The example that I\u0026rsquo;ve given here is a bit dumb (I\u0026rsquo;m not even sure if it would actually result in better compiled CXXRTL code!), but it shows some of the potential of what can be achieved.\nI have only scratched the surface of what can be done with it: there are ways to make a techmap module behave differently based on whether or not certain input bits are constant, you can instruct Yosys to run another Yosys command after performing a techmap iteration, and so forth.\nIf you want to go deeper, you should definitely start by checking out the help instructions, not only of techmap command, but also some of the other ones.\nReferences Main Yosys repo on GitHub\nyosys_techmap_blog repo on GitHub\nContains the Verilog code and the Yosys scripts to generate all the graphs of this blog post.\n","date":"2022-11-24T09:38:52+02:00","image":"http://blog.yosyshq.com/static-2022/yosys_techmap/SB_MAC16_block_diagram.png","permalink":"http://blog.yosyshq.com/p/logic-primitive-transformations-with-yosys-techmap/","title":"Logic Primitive Transformations with Yosys Techmap"},{"content":"The November release of Tabby CAD Suite is now available for download. Notable changes in this version include:\nWe have experimentally added support for EDIF and Liberty verific parsers. They can be used either with the verific [-liberty|-edif] or the read [-liberty|-edif] command. We are evaluating whether it is of interest for us to keep these long-term, so please let us know if you use them and what your experience is!\nIn other YosysHQ news TinyTapeout is an educational project that makes it easier and cheaper than ever to get your digital designs manufactured on an ASIC. By leveraging open source tools like Yosys, the files required for manufacture are run in the cloud. Scroll to the bottom of the build results to see a cool interactive 3d viewer.\n","date":"2022-11-24T00:00:00Z","image":"http://blog.yosyshq.com/static-2022/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20221108-released/","title":"Tabby CAD Suite version 20221108 released!"},{"content":"The October release of Tabby CAD Suite is now available for download.\nThe read and verific commands now support here-documents in scripts, the same way as read_verilog. This is useful e.g. to have small self-contained tests in a single file such as:\nread -sv \u0026lt;\u0026lt;EOT module top(input clk, output reg [1:0] q); wire [1:0] x = 2'b10; always @(posedge clk) q \u0026lt;= x \u0026amp; 2'b11; endmodule EOT prep -top top sim -clock clk -n 1 -w top select -assert-count 1 a:init=2'b10 top/q %i ","date":"2022-10-17T00:00:00Z","image":"http://blog.yosyshq.com/static-2022/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20221011-released/","title":"Tabby CAD Suite version 20221011 released!"},{"content":"This guest post is the first in a two part series by Chris Lasocki.\nIt seems that it was an accident - a generic part of a LED display has become a low cost FPGA development board. The board in question is the Colorlight 5A-75B, which is a so-called receiver card. Featuring a Lattice ECP5 FPGA, supported by Yosys, it allows you to leverage a fully open-source FPGA development toolchain. Priced on average at 20-25 USD, it is a very accessible board.\nThe Colorlight 5A-75B was originally a part of a modular LED display standard. It\u0026rsquo;s a receiver card, which means that it sits between the computer controlling the show, and the LED panels themselves. It fulfills a basic but crucial task of receiving the video signal and driving the RGB panels accordingly. This takes a lot of bandwidth, so it is equipped with a moderately fast ECP5 LFE5U25-F FPGA and two Gigabit Ethernet interfaces. There is also a 16Mbit SDRAM for temporary storage and a Flash memory of the same size for storing the bitstream. It features 8 output ports of a known pinout (HUB75) and 5V outputs. The board has caught attention of hardware hackers and soon after was fully reverse engineered by q3k and others. A schematic with pinouts is available, as well as other documentation. A great amount of work has been done here and this is what enables the Colorlight board to be used in the hacker spirit way.\nAccidentally, this board design happens to be a great compromise between feature-rich and IO-rich. The only on-board peripherals are the basic or high speed ones, which would be hard to connect over the 0.1\u0026quot; pin headers. It is also the only development board with a dual Gigabit Ethernet interface in its price range. Since it\u0026rsquo;s just an FPGA, the 16MBit SDRAM should be enough for most applications, while being easy to implement a controller for.\nHacking the board With the on-board JTAG port, you just need to solder on a 4 pin header and you are ready to upload your own bitstreams to the ECP5 FPGA. This FPGA is fully supported by the Yosys toolchain, from the verilog compiler through place and route engine to the bitstream generator, and along with an open source JTAG adapter like the Bus Pirate (or anything else, really) it only takes a moment to send the bitstream down and see your code run. There is a great deal of user accessible IO broken out on the HUB75 headers.\nThe FPGA has a 25MHz clock directed to it, as well as one onboard LED and a button, which is plenty enough for a Verilog \u0026ldquo;Hello, world!\u0026rdquo; project - blinking the LED.\nThe only downside of this board is lack of inputs by default - You need to replace the 74HC245 output drivers with bidirectional level shifters. However there exists a pin compatible level shifter IC, SN74CBT3245A which can replace the default output driver providing 3v3 bidirectional IO. Other options, such as fabricating tiny PCBs that replace the shifters with wires, or connecting the direction pin of the output drivers to an IO pin are also a possibility.\nSummary The Colorlight 5A-75B is a good choice for those who want to try open-source FPGA programming but do not wish to spend a significant amount of money for a classic development board. The on-board peripherals are enough for a first project to get acquainted with the toolchain. Gigabit Ethernet and SDRAM could also come in handy in future more advanced projects.\nIn the next post I will describe how to write, compile and upload a Verilog project that will blink the onboard led of the 5A-75B board.\nAbout the author Chris \u0026ldquo;polprog\u0026rdquo; Lasocki (@polprogpl) is a long time electronics hacker and an aspiring physicist. FPGAs are one of his hobbies and he is currently writing a thesis in that field. His other interests include laser physics as well as embedded programming projects. He runs a blog at polprog.net.\n","date":"2022-10-16T18:17:00+02:00","image":"http://blog.yosyshq.com/static-2022/colorlight_5a75b.jpg","permalink":"http://blog.yosyshq.com/p/colorlight-part-1/","title":"Introducing the Colorlight 5A-75B board"},{"content":"The September release of Tabby CAD Suite is now available for download.\nSBY SBY now runs multiple tasks in parallel. Additionally it now limits the number of concurrently running subprocesses to the available number of cores. The \u0026ndash;sequential command line option allows you to opt out of running tasks in parallel and the -j N option sets the limit of concurrent subprocesses to N instead of the default. All this is optionally integrated with the make jobserver protocol to enforce the concurrent process limit across other processes launched by make. There is a new SBY option vcd to enable or disable the generation of VCD traces. It defaults to on, but can be set to off when no traces are required to save runtime and disk space. VCD trace generation performance for the smtbmc engine is also improved in this release, so we recommend re-evaluating the performance before turning VCD trace generation off. In other YosysHQ news We have recently overhauled the SBY getting started guide. Have a look if you need to onboard someone for SVA property checking! ","date":"2022-09-06T00:00:00Z","image":"http://blog.yosyshq.com/static-2022/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20220906-released/","title":"Tabby CAD Suite version 20220906 released!"},{"content":"The August release of Tabby CAD Suite is now available for download.\nSBY SBY now uses a more precise logic loop analysis, removing the need to run simplemap on coarse-grain cells that re-use parts of a signal. In other YosysHQ news Since we introduced the new autotune option, we’ve now written up a blogpost with an example on how to get started. ","date":"2022-08-05T00:00:00Z","image":"http://blog.yosyshq.com/static-2022/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20220805-released/","title":"Tabby CAD Suite version 20220805 released!"},{"content":"Sby, our frontend for formal verification, makes it easy to use Yosys with the various open source verification tools that are included in our CAD suites. Sby integrates these tools as engines and provides a unified interface. Additionally, many of the verification tools internally use lower-level tools like SAT and SMT solvers and allow the user to select between different supported solvers.\nMost verification tasks can be performed by several of the supported engines and solvers. Depending on the specific verification task at hand, there can be large performance differences between them. Thus, it makes sense to try several engines and solvers to pick the best performing one.\nWith Sby, switching the engine or solver only requires changing a single line in the “[engines]” section of the .sby file. Still, the large number of engine and solver configurations made it impractical to manually try all of them for every verification task, so it was easy to leave performance on the table by sticking with a worse performing configuration.\nTo help you get the best performance out of Sby, we now introduced the \u0026ndash;autotune option. If you add this option to your usual Sby invocation, it will go ahead and automatically try all recommended engine and solver combinations, producing a report that lists the best performing configurations. You can then copy a configuration from this report into your .sby file to use a faster engine for future sby invocations. From time to time, when updating the CAD suite, or making significant changes to your design, you can run autotune again to see if you are still using the best performing engine.\nSby \u0026ndash;autotune is also a lot smarter than just trying every configuration in sequence. It runs in parallel and knows how to use timeouts and retries so that a single slow engine that would take hours doesn’t keep Sby from quickly discovering a better configuration that finishes in seconds. When selecting the recommended engines and solvers, it also takes into account the design and settings in your .sby file to avoid known incompatibilities or performance issues.\nMore details on how to use and configure the automatic engine selection can be found in the corresponding section of the Sby documentation. If you want to try out the new autotune feature yourself, but don’t have a suitable Sby project at hand, you can try it on the small example project we prepared.\nAs always, we\u0026rsquo;re interested to hear how you get on with our tools\n","date":"2022-07-27T14:41:35+02:00","image":"http://blog.yosyshq.com/static-2022/autotune.png","permalink":"http://blog.yosyshq.com/p/sby-autotune/","title":"Autotune"},{"content":"The July release of Tabby CAD Suite is now available for download.\nSBY An autotune function! This won’t fix your singing, but we hope it will help you to choose a good solver for your application. Please check the new documentation here to get started. Please let us know if you try the new feature. We will write a blogpost about it for the next newsletter. In other YosysHQ news Since tribuf support was added in May, we wrote a short blogpost about Matt’s use of it for his latest ASIC submission. We also added an example to the sby examples. ","date":"2022-07-06T00:00:00Z","image":"http://blog.yosyshq.com/static-2022/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20220706-released/","title":"Tabby CAD Suite version 20220706 released!"},{"content":"Sby, our formal verification tool has recently got better support for tristate circuits. A tristate output is one that can either drive the connected wire to a high or low logic level or be in a high impedance state where it does not drive the output. This allows directly connecting multiple tristate outputs as long as no two are driving the output simultaneously. With tribuf (tristate buffer) support turned on, sby will automatically create assertions for any tristate signals that can be driven via multiples outputs. If more than one tristate output can drive the same wire, such an assertion will fail. For example:\nmodule module1 (input wire active, output wire tri_out); assign tri_out = active ? 1'b0 : 1'bz; endmodule module module2 (input wire active, output wire tri_out); assign tri_out = active ? 1'b0 : 1'bz; endmodule module top_fail (input wire clk, input wire active1, input wire active2, output wire out); module1 module1 (.active(active1), .tri_out(out)); module2 module2 (.active(active2), .tri_out(out)); endmodule And an .sby file with a script section that includes:\nprep -top top_fail flatten; tribuf -formal Will fail with a message like:\nAssert failed in top: tristates.v:3 ($tribuf_conflict$$flatten/module1.$verific$i6$tristates.v:3$9) By ensuring that only one tristate module is active at once, for example\nmodule top_pass (input wire clk, input wire active1, output wire out); module1 module1 (.active(active1), .tri_out(out)); module2 module2 (.active(!active1), .tri_out(out)); endmodule Sby will now finish with no errors. There is no need to add any assertion to the design, with the tribuf -formal command enabled in the [script] section of the sby file, the assertions are added automatically. Note that the flatten command is required when any module outputs can be tristate and that it has to precede the tribuf -formal command.\nYou can try the example out here: https://github.com/YosysHQ/sby/tree/master/docs/examples/tristate The sby file makes use of 2 different task sections.\nI recently used this feature to prove the safety of the tristate bus for an ASIC design. The ASIC combines 13 smaller projects with 45 verilog files. Sby completes a full proof with a depth of 5 clock cycles in 10 seconds. You can take a look at the project\u0026rsquo;s repository and the .sby file.\nThis shows that verifying meaningful properties of a larger design doesn\u0026rsquo;t have to take hours or even days. The time required to prove a property is not set by the overall design complexity. State of the art solvers are very good at cutting through a ton of logic to identify just the relevant parts. In solver terminology this is called an unsatisfiable core and on the hardware side this corresponds to a subcircuit that alone ensures that a property holds. That means you could change everything that is not part of this core circuit and the property would still hold. The complexity of this subcircuit is a much better indicator of the required solver effort.\nIf you are familiar with the cone of influence concept, where you find the relevant logic by following the circuit\u0026rsquo;s structure, this might sound familiar. An important difference is that solvers do not only consider the structure but also the behavior implemented by a circuit, which is more precise. Thus for the same property, an unsatisfiable core circuit can be much smaller than the cone of influence.\nFor selecting between different projects within a single ASIC design, most of the projects\u0026rsquo; logic is not part of the unsatisfiable core. Only the logic responsible for selecting which tristate outputs are active together with the automatically added conflict checks needs to be considered. This is great because for medium to large projects with many source files, the solver can still provide an answer very quickly.\nIf you have experience with proving simple properties in large designs please let us know - we’re always interested in how people are using our tools.\n","date":"2022-06-17T17:28:17+02:00","image":"http://blog.yosyshq.com/static-2022/tristate.png","permalink":"http://blog.yosyshq.com/p/formal-trisate-support/","title":"Formal Tristate Support"},{"content":"The June release of Tabby CAD Suite is now available for download.\nYosys A big overhaul of memory inference in Yosys. The new pass memory_libmap supports a wider variety of memory patterns, such as single-port memories or asymmetric memories. It will also strictly respect verilog semantics in cases of address collision, adding emulation circuitry to ensure the synthesized behavior matches simulation. To omit the emulation circuitry even in cases where it is required for correctness, you can add the (* no_rw_check *) attribute to the array declaration of the memory. To disable collision handling globally, calling memory with the -no-rw-check option is also possible (and the corresponding option has been added to all synth passes using the new memory_libmap pass).\n","date":"2022-06-10T00:00:00Z","image":"http://blog.yosyshq.com/static-2022/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20220610-released/","title":"Tabby CAD Suite version 20220610 released!"},{"content":"The May release of Tabby CAD Suite is now available for download.\nSBY The tribuf pass now supports a -formal option that converts inferred tri-state buffers within a module into equivalent non-tri-state logic for formal verification. It automatically adds assertions that detect multiple drivers driving the same net simultaneously. (When using tri-state I/O across modules, tribuf -formal should be preceded by a flatten pass). Several changes in the handling of x values during formal verification. In particular, when using the Verific frontend, during the initial time step, value change expressions ($rose, $fell, $changed, $stable) are now always computed as if the argument changed from x to its initial value. This follows the SystemVerilog standard and ensures that any high (or low) signal starts at a step where $rose (or $fell) is true. In other YosysHQ news Teodor-Dumitru Ene recently spoke about Open-Source Hardware Addition on SKY130. He has made a Yosys plugin that allows the designer to choose what algorithm to use. We are very happy to announce that Mullvad are sponsoring the development of the open source tools. Thanks Mullvad, and if you need a VPN, be sure to check them out! ","date":"2022-05-12T00:00:00Z","image":"http://blog.yosyshq.com/static-2022/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20220512-released/","title":"Tabby CAD Suite version 20220512 released!"},{"content":"Teodor-Dumitru Ene will be presenting his work on adder optimisations, he\u0026rsquo;ll be covering:\nPrefix sums His research Adder-specific quirks and optimizations Future goals Questions! Please join us:\nTuesday, 10 May · 17:30 – 18:30 CEST Streaming on youtube ","date":"2022-05-06T09:38:52+02:00","image":"http://blog.yosyshq.com/static-2022/adders.jpg","permalink":"http://blog.yosyshq.com/p/optimising-adders/","title":"Teodor-Dumitru and the Complexity of Adder Implementations in Hardware"},{"content":"The April release of Tabby CAD Suite is now available for download.\nYosys The sim command now allows co-simulation with stimulus values from aiger and btor2 witness files as well as traces in VCD or FST format. Co-simulation of designs with multiple clock domains was improved. SBY The --keep-going option was added to the smtbmc engine. With this option, the solver will continue to check the remaining properties even after an assertion fails. To use it, add the option between the engine and the solver in the .sby file:\n[engines] smtbmc --keep-going boolector The JUnit report produced by sby will now list the status individually for each property when the engine supports it (currently only with smtbmc).\nIn other YosysHQ news We just welcomed 3 new people to the team; Jannis, Lofty and Krystine. They’ll be helping us to improve the formal and FPGA tooling, and improve our documentation. If you don’t already follow us on twitter - we post as YosysHQ. Whitequark just had a great ‘ask me anything’ on digital logic. As a small company, we really appreciate being recommended to people - please let us know if you have any leads! ","date":"2022-04-06T00:00:00Z","image":"http://blog.yosyshq.com/static-2022/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20220406-released/","title":"Tabby CAD Suite version 20220406 released!"},{"content":"Yosys is probably best known for providing synthesis for FPGA targets, but it\u0026rsquo;s a very flexible tool capable of a lot more.\nOpenLane, SiliconCompiler and Coriolis2 are 3 examples of open source ASIC flows, which has been an active field of development over the last year.\nWe\u0026rsquo;re very happy to see our tools get used in the first Google sponsored tapeouts, helping to make the world\u0026rsquo;s first chips made with an open source PDK, and open source all the way down to the designs.\nIf you want to find out more about what happened in the world of open source silicon in 2021, you can see our CSO Matt Venn\u0026rsquo;s recent presentation for Hackaday Remoticon here:\n","date":"2022-02-28T11:23:54+01:00","permalink":"http://blog.yosyshq.com/p/open-source-silicon-with-yosys/","title":"Open Source Silicon with Yosys"},{"content":"Code: https://github.com/YosysHQ-Docs/Blog-Async-Load-FFs\nPart 1: The Bad News We have recently added support for asynchronous load flip-flops to Yosys for a customer project. However, we consider this a problematic feature in a (System-)Verilog synthesis tool, and thus I’d like to take this opportunity to explain why one should avoid using asynchronous load flip-flops in new (System-)Verilog designs.\nWhat are asynchronous load flip-flops An asynchronous load flip-flop is a type of flip-flop with asynchronous reset for which the reset value is not a compile-time / synthesis-time constant.\nreg async_load_ff_q; wire async_load_ff_reset_val = \u0026lt;dynamic_expression\u0026gt;; always_ff @(posedge clock, posedge load) if (load) async_load_ff_q \u0026lt;= async_load_ff_reset_val; else async_load_ff_q \u0026lt;= ...; This distinguishes them from the more common asynchronous set (reset) flip-flops, for which the reset value is a compile-time (synthesis-time) constant.\nreg async_reset_ff_q; localparam async_reset_ff_reset_val = \u0026lt;constant_expression\u0026gt;; always_ff @(posedge clock, posedge reset) if (reset) async_reset_ff_q \u0026lt;= async_reset_ff_reset_val; else async_reset_ff_q \u0026lt;= ...; IEEE Std 1364.1-2002, the IEEE Standard for Verilog Register Transfer Level Synthesis, does allow such asynchronous load flip-flops in synthesis, but states that the synthesis results will only match the behavior of the original Verilog code under certain conditions.\nThe problem with Verilog and asynchronous load flip-flops The key insight is that the way an asynchronous reset is modelled using Verilog always blocks is not sensitive to the data signals providing the asynchronous load value. Thus, if the data signals are changing while the asynchronous reset is active, the new data is not loaded into the flip-flop when neither clock nor the asynchronous reset is toggling.\nConsider the following SystemVerilog design (dut.sv):\nmodule dut ( input clk1, clk2, arst, output reg [7:0] cnt1, cnt2 ); always_ff @(posedge clk1 or posedge arst) if (arst) cnt1 \u0026lt;= 0; // constant expression (async reset) else cnt1 \u0026lt;= cnt1 + 7; always_ff @(posedge clk2 or posedge arst) if (arst) cnt2 \u0026lt;= cnt1; // dynamic expression (async load) else cnt2 \u0026lt;= cnt2 + 11; endmodule And the following test bench (tb.sv):\nmodule tb; reg clk1 = 0, clk2 = 0, arst = 0; wire [7:0] cnt1, cnt2; dut dut (clk1, clk2, arst, cnt1, cnt2); task do_clk1; clk1 = 1; #5; clk1 = 0; #5; endtask task do_clk2; clk2 = 1; #5; clk2 = 0; #5; endtask task do_arst; arst = 1; #5; arst = 0; #5; `ifdef DOUBLE_ARST arst = 1; #5; arst = 0; #5; `endif endtask initial begin #10; do_arst; $display(cnt1, cnt2); repeat (5) do_clk1; $display(cnt1, cnt2); do_arst; $display(cnt1, cnt2, \u0026#34; \u0026lt;--\u0026#34;); repeat (5) do_clk2; $display(cnt1, cnt2); do_arst; $display(cnt1, cnt2); end endmodule Running it without and with -DDOUBLE_ARST produces the following output:\n$ make run0 iverilog -g2012 -o sim0 -s tb tb.sv dut.sv ./sim0 0 x 35 x 0 35 \u0026lt;-- 0 90 0 0 $ make run1 iverilog -g2012 -o sim1 -s tb -DDOUBLE_ARST tb.sv dut.sv ./sim1 0 0 35 0 0 0 \u0026lt;-- 0 55 0 0 In the first case with a single pulse on arst, the second counter is reset to the non-zero value of the first counter from before the reset pulse.\nBut a real-world asynchronous load flip-flop would of course behave like a transparent latch while the reset pulse is high, propagating the new (zero) value of the first counter to the second counter register. But this only happens in simulation when we pulse the reset signal a second time.\nThis can lead to non-trivial simulation-synthesis mismatches that are hard to debug, and may result in a chip that does not function as expected.\nThus, asynchronous load flip-flops should be avoided in (System)Verilog designs, or at least it should be formally verified that the asynchronous load value of such a flip-flop can never change while the reset signal is active.\nThis is in line with IEEE Std 1364.1-2002 requirements for sequential logic verification:\nWhen asynchronous data is assigned, the asynchronous data shall not change during the period in which the asynchronous control (the condition under which the data is assigned) is active.\nIEEE Std 1364.1-2002, Section 4.2\nIt is worth noting that a similar problem exists with flip-flops that have both asynchronous set and reset: If both are asserted and then one is released after the other, the one that’s released later should take precedence over the one that’s released earlier. However, since the always block is not triggered by the falling edge of the set or reset signal, releasing just one of the two will have no effect on the flip-flop output. IEEE Std 1364.1-2002 also acknowledges this issue:\nThe problem occurs when both reset and preset are asserted at the same time and reset is removed first. When reset is removed (posedge rst_n), the always block is not activated. This means that the output will continue to drive the reset output to ‘0’ until the next rising clock edge. A real flip-flop of this type would immediately drive the output to ‘1’ because the set_n signal is an asynchronous preset. This potentially could cause a mismatch between pre-synthesis and post-synthesis simulations using this model.\nIEEE Std 1364.1-2002, Appendix B.6\nPart 2: The Good News In this section we discuss different design methods that avoid the use of behavioral Verilog code to model asynchronous load FFs.\nInstantiate (Vendor) Primitives The best and easiest way of dealing with this issue is to instantiate FF primitives directly. This can either be vendor cells, or a user-defined module for which we chose different implementations for simulation and synthesis, one with correct simulation behavior, and one that is synthesizable, respectively.\nThe new DUT would look something like this (dut_myff.sv):\nmodule dut ( input clk1, clk2, arst, output reg [7:0] cnt1, cnt2 ); myff ff1[7:0] (cnt1, cnt1 + 8\u0026#39;d 7, clk1, arst, 8\u0026#39;h 00), ff2[7:0] (cnt2, cnt2 + 8\u0026#39;d 11, clk2, arst, cnt1); endmodule When instantiating a Vendor primitive one should always double-check that the vendor simulation library does model asynchronous loads correctly, for example using the techniques described in the next two sections.\nSimulation model using Verilog UDP Verilog UDP primitives can be used to correctly model the behavior of asynchronous load flip-flops. But UDPs are not synthesizable, so we need to also provide a synthesizable implementation of an asynchronous load flip-flop (myff_udp.sv):\n`ifdef SYNTHESIS module myff ( output reg q, input d, clk, arst, rval ); always @(posedge clk or posedge arst) if (arst) q \u0026lt;= rval; else q \u0026lt;= d; endmodule `else primitive myff (q, d, clk, arst, rval); input d, clk, arst, rval; reg q; output q; table // D C R V : Q : Q\u0026#39; ? ? 1 0 : ? : 0 ; // async reset ? ? 1 1 : ? : 1 ; // async set 0 p 0 ? : ? : 0 ; // posedge clock, d=0 1 p 0 ? : ? : 1 ; // posedge clock, d=1 ? n 0 ? : ? : - ; // negedge clock * ? ? ? : ? : - ; // any data edge ? ? * ? : ? : - ; // any arst edge ? ? ? * : ? : - ; // any rval edge endtable endprimitive `endif Running our test-bench now yields the expected result, even when we pulse the asynchronous load signal only once:\n$ make run2 iverilog -g2012 -o sim2 -s tb tb.sv dut_myff.sv myff_udp.sv ./sim2 0 0 35 0 0 0 \u0026lt;-- 0 55 0 0 Simulation model using procedural assign and deassign Another approach is to “fix up” the asynchronous load using procedural assign and deassign (myff_ada.sv):\nmodule myff ( output reg q, input d, clk, arst, rval ); always_ff @(posedge clk or posedge arst) if (arst) q \u0026lt;= rval; else q \u0026lt;= d; `ifndef SYNTHESIS always @(arst) if (arst) assign q = rval; else deassign q; `endif endmodule Running our test-bench on this version also yields the expected result:\niverilog -g2012 -o sim3 -s tb tb.sv dut_myff.sv myff_ada.sv ./sim3 0 0 35 0 0 0 \u0026lt;-- 0 55 0 0 Of course it’s also possible to use procedural assign and deassign directly in the design to “fix up” the behavior of asynchronous load flip-flops (dut_ada.sv):\nmodule dut ( input clk1, clk2, arst, output reg [7:0] cnt1, cnt2 ); always_ff @(posedge clk1 or posedge arst) if (arst) cnt1 \u0026lt;= 0; else cnt1 \u0026lt;= cnt1 + 7; always_ff @(posedge clk2 or posedge arst) if (arst) cnt2 \u0026lt;= cnt1; else cnt2 \u0026lt;= cnt2 + 11; `ifndef SYNTHESIS always @(arst) if (arst) assign cnt2 = cnt1; else deassign cnt2; `endif endmodule However, sprinkling procedural assign and deassign statements and ifndef-SYNTHESIS-blocks all over the design is much more error prone than implementing this work-around only once in a custom cell type that can then be instantiated wherever needed.\nThe latch+flip-flop trick The following technique is used on some FPGA architectures to emulate asynchronous-load flip-flops using latches and asynchronous-reset flip-flops only. It can be used to completely avoid asynchronous-load FFs while preserving the semantic of such elements (myff_hack.sv):\nmodule myff ( output q, input d, clk, arst, rval ); // a latch to store the async-load value reg latched_rval; always @* if (arst) latched_rval = rval; // a regular FF to store the clocked data value reg q_without_reset; always @(posedge clk) q_without_reset \u0026lt;= d; // an asynchronous-reset flip-flop to remember last event reg last_event_was_clock; always @(posedge clk or posedge arst) if (arst) last_event_was_clock \u0026lt;= 0; else last_event_was_clock \u0026lt;= 1; // output either the latched reset value or clocked data value assign q = last_event_was_clock ? q_without_reset : latched_rval; endmodule Running our test-bench a last time gives the expected result for this solution as well:\niverilog -g2012 -o sim5 -s tb tb.sv dut_myff.sv myff_hack.sv ./sim5 0 0 35 0 0 0 \u0026lt;-- 0 55 0 0 This is a useful last resort solution for designs that absolutely require asynchronous-load flip-flop semantics, and where the risks associated with using different synthesis and simulation models for such a component are not acceptable.\n","date":"2021-11-30T00:00:00Z","image":"http://blog.yosyshq.com/static-2021/asyncff.png","permalink":"http://blog.yosyshq.com/p/async-load-ff/","title":"Why Asynchronous Load Flip-Flops Should Be Avoided"},{"content":"YosysHQ are pleased to announce a new pricing option for small companies with one full time engineer.\nFor just €500 per month (excl. VAT), you can get our ‘Solo bundle’:\n2 nodes of TabbyCAD Suite, offering industry compatible language support and our formal verification tools and verification IP. Unlimited number of users/processes per node. (Up to 32 CPUs per node.) Not time limited, use in your continuous integration systems. Support that includes potential for custom work and access to our technical team. For two full time engineers, we have our ‘Solo bundle plus’ which adds another 2 TabbyCAD nodes for an additional €400 per month.\nWe also have competitive prices for larger teams.\nFor an evaluation license, or to discuss your requirements further please contact us at contact@yosyshq.com.\n","date":"2021-07-26T15:35:40+02:00","permalink":"http://blog.yosyshq.com/p/pricing-for-small-companies/","title":"New pricing for small companies"},{"content":"This Application Note was written with the intention of showing a brief introduction to SVA, and is definitely not a substitute for extensive training. To learn more about formal verification and SVA, it is recommended to book the course given by the FPV specialists at YosysHQ.\nA brief history of SystemVerilog Assertions SVA layers definition and examples Assertion types, sequential property operators A short description of liveness and safety properties Practical examples using the sequence builder module written by our CTO Claire Xen. https://yosyshq.readthedocs.io/projects/ap109\nFeel free to give us feedback and suggest new topics.\n","date":"2021-07-07T12:37:04+02:00","permalink":"http://blog.yosyshq.com/p/ap109/","title":"App Note 109"},{"content":"For a long time people have asked us for quality long form content that shows how to get the best from our formal tools.\nWe have started a series of app notes, with the first being about cover and witness for SVA properties. Otherwise known as \u0026lsquo;Am I testing what I think I\u0026rsquo;m testing\u0026rsquo;!\nWhat You will learn in this app note:\nDefault clocking and default disable declarations Sequences and cycle delays Overlapping and non-overlapping implication syntax and semantic Weak precondition cover and witness How to apply that to a practical HDL code example https://yosyshq.readthedocs.io/projects/ap120\nFeel free to give us feedback and suggest new topics.\n","date":"2021-05-20T14:04:45+02:00","permalink":"http://blog.yosyshq.com/p/ap120/","title":"App Note 120"},{"content":"YosysHQ.com is the new home for the team maintaining Yosys and the related Open Source EDA projects, and the commercial products and services we offer.\nOur team is led by N. Engelhardt as CEO, Claire Wolf as CTO, and Matt Venn as CSO. We are looking to work with more people, so feel free to contact us: contact@yosyshq.com\nTabby CAD Suite is a bundle of our well-known Open Source EDA software packages, combined with additional components that allow seamless integration of our tools in typical industrial digital design environments.\nWe also provide support and training for users of our Tabby CAD Suite package and for developers building their work on top of our open source projects.\nIn addition, we welcome opportunities to get involved with new projects large and small. We are looking to grow our collaborations with industry and academic partners on improving and expanding our synthesis, place and route, and formal verification flows.\nWe look forward to a positive relationship with the Open Source EDA community and external partners.\nMake sure you visit our website www.yosyshq.com and send us an email or tweet at us @YosysHQ to say hi!\n","date":"2021-02-08T00:00:00Z","permalink":"http://blog.yosyshq.com/p/hello/","title":"Hello World!"}]