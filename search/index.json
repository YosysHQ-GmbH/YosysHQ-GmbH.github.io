[{"content":"The March release of Tabby CAD Suite is now available for download. Notable changes in this version include:\nWe\u0026rsquo;ve added a new command abstract that can be used to replace concrete signal values with unconstrained abstract values during formal verification. See the documentation for more details. In other YosysHQ news:\nIn our most recent Yosys User‚Äôs Group, Emil presented ‚ÄúASIC synthesis with Yosys‚Äù. He covered ASIC synthesis, Yosys scripts, abc scripts and new Yosys features for ASIC. The talk was recorded and you can watch it here: https://youtu.be/PlS4e5S5bCA Happy March, The YosysHQ Team\n","date":"2025-03-12T00:00:00Z","image":"http://blog.yosyshq.com/static-2023/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20250312-released/","title":"Tabby CAD Suite version 20250312 released!"},{"content":"This guest blog post was written by Rohith V.\n# RISC-V Formal Verification Framework Extension for Synopsys VC Formal Imagine deploying a RISC-V processor in an embedded system, only to discover an instruction-level bug after manufacturing‚Äîthis could be a costly mistake. Formal verification ensures that such issues never make it past the design phase, and tools like riscv-formal help automate this process. However, many engineers rely on proprietary tools like Synopsys VC Formal, making integration with open-source solutions a challenge‚Äîuntil now.\nThe riscv-formal framework has been a game-changer, providing an open-source solution for verifying RISC-V cores against the official ISA specification. While powerful, its integration with industry-grade proprietary tools has remained complex. This project bridges that gap by extending riscv-formal to seamlessly interface with Synopsys VC Formal, enabling engineers to harness its advanced capabilities while maintaining a structured and efficient verification approach.\nIn this post, we‚Äôll explore the role of formal verification in RISC-V core validation, the motivation behind this integration, and the methodology that makes it possible. Ultimately, this extension enhances accessibility and usability, providing the broader verification community with a streamlined, industry-compatible solution.\n# About the Framework # Before We Dive In\u0026hellip; Before diving into the project, let\u0026rsquo;s take a quick look at the riscv-formal framework and understand why it plays a crucial role in RISC-V core verification.\n# What is riscv-formal? riscv-formal is an open-source formal verification framework designed to rigorously verify RISC-V processors against the RISC-V ISA specification. Built on the FOSS SymbiYosys Formal Verification Flow, it ensures that a processor implementation behaves correctly at the instruction and architectural levels.\n# Why is riscv-formal Important? Automated Property Checking: Ensures compliance with the RISC-V ISA without requiring manual testbenches. Minimal Setup, Maximum Coverage: Works with any RISC-V design using an RISC-V Formal Interface (RVFI) wrapper. # How it Works RVFI Wrapper: Wraps the core-under-test with an RVFI-compliant interface for compatibility. Formal Checkers: A set of predefined checkers checks the whole core thoroughly. Verification Engines: Uses predefined assertions and constraints to validate core behavior. Counterexample Analysis: If a check fails, it generates a trace of execution (CEX) to debug violations. # Limitations \u0026amp; Extending to Proprietary Tools While riscv-formal is highly effective for open-source formal verification, its native tooling (SBY/Yosys) does not support proprietary EDA tools. This is where our extension comes in‚Äîadapting riscv-formal for Synopsys VC Formal, bridging the gap between open-source and commercial verification flows.\n# Project Goals By adapting the riscv-formal framework (originally built for SymbiYosys) to work with Synopsys VC Formal, this project aims to:\nSeamless Integration with VC Formal ‚Äì Ensure that riscv-formal works effortlessly with Synopsys VC Formal, simplifying the verification process without requiring extensive modifications. Improve Usability ‚Äì Deliver clear documentation and practical examples to help engineers effectively apply the framework. Enable Easy .sby ‚Üí .tcl Conversion ‚Äì Support straightforward translation of .sby configurations into .tcl scripts, even outside the framework. By achieving these goals, the project enhances the efficiency, accessibility, and adoption of formal verification for RISC-V cores, fostering wider collaboration in the verification community.\n# Key Challenges in Transitioning to VC Formal Conversion from SymbiYosys Flow: The .sby configuration files used in riscv-formal are specific to SymbiYosys. VC Formal, on the other hand, operates using Tcl-based scripts, requiring a structured translation mechanism to adapt the verification flow. Environment Setup \u0026amp; Automation: Automating the process‚Äîso that users can easily set up VC Formal verification with minimal manual intervention‚Äîwas a key goal in this adaptation. # Verification Process # i. FOSS SymbiYosys Formal Verification Flow This flow demonstrates the formal verification process using the riscv-formal framework with the open-source SymbiYosys tool. It consists of components like RVFI, the wrapper, and checks.cfg. These components are used to generate .sby files, which are then processed by SymbiYosys to run verification checks and produce the results, ensuring that the RISC-V implementation adheres to formal specifications. This flow represents a streamlined, FOSS-based approach to formal verification.\n# ii. Synopsys VC Formal Verification Flow This flow illustrates the modified process, where the riscv-formal framework is used with Synopsys VC Formal. The .sby files from the riscv-formal framework are first converted to .tcl scripts using a custom sby to tcl converter before being processed by VC Formal to generate verification results.\nThe framework consists of three key stages, each automated for smooth verification:\nPre-Processing: Converts .sby files into .tcl scripts for VC Formal compatibility. Processing: Runs the formal checks, collects logs, and categorizes warnings \u0026amp; errors. Post-Processing: Summarizes verification results, helping users quickly identify pass/fail conditions. To achieve this, we‚Äôve extended the framework with four core components:\n# 1Ô∏è‚É£ sby_to_tcl.py ‚Äì Automating Test Setup (Pre-Processing) The sby_to_tcl.py script automates the conversion of SymbiYosys .sby files into VC Formal-compatible .tcl scripts. It also creates a Makefile that organizes multiple verification tasks, allowing batch execution with a single command.\n# üîπ Why is this important? Eliminates manual effort in handling .tcl files. Enables batch verification by processing multiple .sby files at once. Organizes output systematically in a dedicated vcf directory. # 2Ô∏è‚É£ vcf_cexdata.sh ‚Äì Error \u0026amp; Warning Processing (Processing Stage) During the verification execution, the vcf_cexdata.sh script ensures structured handling of warnings and errors. Instead of overwriting logs, it captures and organizes logs for all checks, ensuring every warning/error is properly recorded.\n# üîπ Key Features: Prevents loss of information by storing logs separately. Formats errors in an easy-to-read structure (warnings.txt, errors.txt). Provides a quick summary of issues across multiple checks. # 3Ô∏è‚É£ vcf_res_process.py ‚Äì Summarizing Verification Results (Post-Processing) After verification, vcf_res_process.py extracts key results from each check, categorizing assertions as PASS, FAIL, or INCONCLUSIVE and consolidating everything into a single summary file (results.txt).\n# üîπ Why does this matter? Saves time‚Äîno need to inspect multiple files manually. Provides a high-level overview of all formal verification checks. Helps users quickly identify issues that need further debugging. # 4Ô∏è‚É£ Makefile ‚Äì Automating the Entire Workflow The Makefile serves as the backbone of automation, orchestrating all three stages. With simple commands like make vcf_check, users can run all checks, collect results, and review summaries without manually executing scripts.\n# üîπ Key Features: One-command execution of all verification steps. Automated log collection \u0026amp; clean-up for an organized workflow. Results displayed directly in the terminal for quick review. For a more detailed breakdown on each file/process, check out the complete repository on GitHub! üöÄ\n# General Applicability An interesting aspect of this process is that it is not exclusive to riscv-formal. In fact, this approach can be adapted for any .sby file(s). The automation framework we\u0026rsquo;ve built for converting .sby files to .tcl scripts, handling formal verification results, and structuring the workflow can be applied to a wide range of formal verification tasks beyond RISC-V.\nThis flexibility makes it a powerful solution for integrating SymbiYosys-based verification flows with commercial formal tools like Synopsys VC Formal, streamlining the entire process across different projects.\n# Going the Other Way: From VC Formal to SBY Let\u0026rsquo;s go the other way for a bit‚Äîwhat if we want to take .tcl files from VC Formal and convert them back into .sby files for SymbiYosys?\n# Initial Challenges Faced with SymbiYosys When I first started using SymbiYosys (SBY) for formal verification, I encountered several challenges:\nToolchain Dependencies: SBY relies on open-source tools like Yosys, Boolector, and ABC. Ensuring proper installation and configuration was time-consuming. Assertion Language Differences: SystemVerilog Assertions (SVA) supported in VC Formal required workarounds in SBY due to syntax or feature limitations. Despite these hurdles, open-source formal verification tools have improved significantly and can handle complex verification tasks.\n# Automating the Conversion: From .tcl to .sby The scripting ideas used in our Python automation can serve as a foundation for reversing the process. Just like sby_to_tcl.py converts .sby to .tcl, a similar script could parse .tcl files and generate .sby files, but key challenges remain:\nLack of Direct Equivalence: VC Formal scripts contain proprietary directives that do not have an exact counterpart in SymbiYosys. Complex Conversions: While a fully automated VC Formal-to-SBY conversion may not be feasible, structured scripting can reduce manual effort significantly. Fortunately, once the .sby files are reconstructed, the existing riscv-formal automation‚ÄîMakefile execution, error handling, and result processing‚Äîremains intact.\nA structured conversion process would enable bidirectional compatibility between open-source and proprietary formal verification tools.\n# SymbiYosys Flow vs. VC Formal Flow Comparison of SymbiYosys Flow and Synopsys VC Formal (VCF) flows:\nFlow SymbiYosys (SBY) Flow VC Formal (VCF) Flow Configuration File .sby file (SBY-based) .tcl file (Tcl-based) Tool Used SymbiYosys + Yosys Synopsys VC Formal Solver Backend Boolector, Yices2, etc., Synopsys‚Äô internal solvers Counterexample Debugging GUI-based + logs GUI-based + logs Execution Automation Python, Shell \u0026amp; Makefile Python, Shell \u0026amp; Makefile # Future Scope Extending to Other Proprietary Tools\nWhile this extension integrates Synopsys VC Formal with riscv-formal, the approach can be further extended to other commercial formal verification tools. Automating .sby file conversion and structured result handling can help streamline workflows across multiple environments.\nMaintaining Compatibility with File Format Changes\nThis extension relies on the .sby file structure from riscv-formal and the .tcl scripting format used by VC Formal. If either of these formats evolve, updates will be needed to ensure compatibility. Keeping the automation scripts adaptable to such modifications will be crucial for long-term usability.\nBy continuously adapting, this extension can remain a valuable tool for formal verification, extending its reach to new tools and maintaining alignment with updates in the riscv-formal ecosystem.\n# Results We have successfully developed a complete extension that seamlessly integrates the riscv-formal framework with Synopsys VC Formal (VCF), ensuring an efficient, automated, and user-friendly verification experience.\nUsing this extended framework, we formally verified our Single Cycle RISC-V core (SCRV32I) and cross-checked results with SymbiYosys. The verification confirms that our core adheres to the RISC-V ISA specifications, ensuring correctness and compliance.\n# üîç Practical Example For a detailed walkthrough, refer to this section of the complete repository on GitHub, where we provide a step-by-step guide to implementing this extension on the example SCRV32I processor.\nThe below section is dedicated to guiding you through the process of configuring custom RISC-V designs.\nThis practical approach ensures that users can replicate adapt, and extend the verification flow to their own processor designs.\n# Configuring a New RISC-V Processor First, refer to the riscv-formal repository and follow the steps outlined in the riscv-formal guide. Complete everything up to step 5. You don\u0026rsquo;t need to run step 5, as it involves using an open-source tool. For our purpose, we will run it using the VC Formal tool, so step 5 can be skipped. If you\u0026rsquo;re interested, you can explore it, but it\u0026rsquo;s not required for this process.\nOnce the RVFI (RISC-V Formal Interface), wrapper.sv file, and checks.cfg file are implemented for your RISC-V processor as per the steps in the riscv-formal repository, you can proceed with running the RISC-V formal framework for your core on the Synopsys VC Formal Tool.\n(Note: You may need to refer to the entire repository to complete this part, not just the section linked here.)\nCopy the vcf_cexdata.sh and Makefile files from the cores/scrv32i folder into your core folder. (Remember to copy the vc_formal folder to the root directory if you have cloned the official riscv-formal repository.)\n(Note: Only the vc_formal folder in the root directory, the vcf_cexdata.sh file in the scrv32i folder, and a few additions to the Makefile inside the scrv32i directory were created to implement this extension. - So copy these files/folder to the right location and it should work with no hassle)\nNavigate to your core directory and run:\ncd cores/{core} make vcf_clean make vcf_check Once the process is complete, the terminal will display results in the following order:\nWarnings Errors Verification results (PASS/FAIL/INCONCLUSIVE/UNKNOWN - If failed to run) Then you can utilize features such as running specific checks (including in GUI mode), launching the GUI, and customizing checks to run or skip, as shown in the \u0026lsquo;Running the Example SCRV32I Processor (For Understanding the Workflow)\u0026rsquo; section above.\n# Conclusion # Bridging the Gap: RISC-V Formal Meets Synopsys VC Formal The RISC-V Formal Verification Framework Extension for Synopsys VC Formal bridges the gap between open-source and industry-grade proprietary tools, making formal verification more accessible, efficient, and scalable.\nWith automated .sby to .tcl conversion, structured result handling, and batch execution support, this extension simplifies the entire verification process for RISC-V cores‚Äîand beyond.\n# But This Is Just the Beginning\u0026hellip; The methodologies introduced here can be extended to other formal verification tasks, making it easier to integrate open-source flows with commercial EDA tools. Whether you‚Äôre using SymbiYosys, VC Formal, or exploring bidirectional compatibility, this framework lays the foundation for a more automated, scalable, and interoperable verification ecosystem.\nüîé Want to dive deeper? Explore the full implementation in the GitHub repository: riscv-formal-vc-formal-extension üöÄ\nBy embracing automation, interoperability, and scalability, we can push the boundaries of formal verification‚Äîensuring that RISC-V processors and other designs are functionally correct and future-proof.\nLet‚Äôs build smarter, faster, and more robust verification flows‚Äîtogether! üî¨üí°\n","date":"2025-02-27T15:00:00+05:30","image":"http://blog.yosyshq.com/static-2025/Sby.png","permalink":"http://blog.yosyshq.com/p/risc-v-formal-verification-framework-extension-for-synopsys-vc-formal/","title":"RISC-V Formal Verification Framework Extension for Synopsys VC Formal"},{"content":"In what was a major achievement in open source FPGA development, we have now added support for the largest FPGA so far supported by open source tooling! 500,000 LUTs!\nIn November 2024 we successfully concluded the European Space Agency funded project in collaboration with NanoXplore, known for their space rated FPGAs.\nThe tool provides developers with a flexible and customizable option for designing for NG-Ultra FPGAs, offering increased reliability through the ability to cross-verify designs using two independent tools.\nFuture work could focus on expanding support within nextpnr to cover additional FPGA primitives, such as high-speed I/O blocks and SoC integration making it more useful for high complexity designs.\nFor more information about the project‚Äôs results you can read the official report here:\nAn open source FPGA toolchain for a European space-grade FPGA | Nebula Public Library\n","date":"2025-02-19T16:00:00+01:00","image":"http://blog.yosyshq.com/static-2025/esa.png","permalink":"http://blog.yosyshq.com/p/an-open-source-fpga-toolchain-for-a-large-european-space-grade-fpga/","title":"An open source FPGA toolchain for a large European space-grade FPGA "},{"content":"The February release of Tabby CAD Suite is now available for download. No user-facing updates in this release‚Äîonly internal optimizations and bug fixes.\nIn other YosysHQ news:\nWe just published news on our successful fulfillment of an ESA funded project to add open source support for NanoXplore‚Äôs space rated FPGAs. Happy February, The YosysHQ Team\n","date":"2025-02-11T00:00:00Z","image":"http://blog.yosyshq.com/static-2023/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20250211-released/","title":"Tabby CAD Suite version 20250211 released!"},{"content":"The December release of Tabby CAD Suite is now available for download. Notable changes in this version include:\nFixed some recurring issues with verific -lib mode. You should no longer see errors when the module definitions to be loaded as blackboxes have contents that instantiate other, unknown modules. Also, parameter values on blackbox modules and their instantiations should now be imported correctly into Yosys again. Additional functions for design inspection have been added to the TCL integration. The setenv command has been added to allow setting environment variables from within yosys scripts. This is useful e.g. to set variables used in file lists before loading them with verific -f xxx.f. In other YosysHQ news:\nThe Moosic plugin we wrote about at the start of the year is now silicon proven! We recently released initial support for the NanoXplore NG-Ultra in nextpnr. This was an activity funded under the European Space Agency\u0026rsquo;s Open Space Innovation Platform. At our most recent YUG, Katharina Ceesay-Seitz presented her work on using formal verification for detecting microarchitectural information leakage - watch the recording here. Happy December, and if you need a last minute gift idea - why not consider the gift of formal verification!\n","date":"2024-12-11T00:00:00Z","image":"http://blog.yosyshq.com/static-2023/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20241211-released/","title":"Tabby CAD Suite version 20241211 released!"},{"content":"The November release of Tabby CAD Suite is now available for download. Notable changes in this version include:\nString attributes are represented more efficiently in the in-memory RTLIL netlist, using a different implementation than bit vector attributes. We have observed reductions in peak memory usage of up to 30% for real world designs. For plugin maintainers, this means some breaking changes if you were directly accessing the bits member of an RTLIL::Const. The bits member has been removed. To access any attribute as a bit vector, use the bits() method instead, which returns a const iterator. To modify a Const, you can call std::vector\u0026amp;lt;RTLIL::State\u0026gt;\u0026amp; get_bits() which forces the implementation to a bit vector. To get the number of bits, use the new Const::size() method instead of bits.size(). In other YosysHQ news:\nAfter a long summer break, Yosys Users Group meetings have resumed again. Our last meeting on October 29th had Katharina CeesaySeitz from ETH Z√ºrich present her work on using special netlist transformations in a custom Yosys pass in combination with formal verification to detect microarchitectural information leakage via hardware timing side channels. If you\u0026rsquo;d like to be notified of our next YUG meeting, subscribe to our newsletter! Watch her talk on our Youtube channel. Happy November,\nThe YosysHQ Team\n","date":"2024-11-05T00:00:00Z","image":"http://blog.yosyshq.com/static-2023/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20241105-released/","title":"Tabby CAD Suite version 20241105 released!"},{"content":"The October release of Tabby CAD Suite is now available for download. Notable changes in this version include:\nFixed an issue in SBY that could lead to the wrong hierarchical path being printed for an assertion failure if multiple instances of the same module exist in the design. Builds for Macs with Apple silicon will now be included in the releases. In other YosysHQ news:\nOur team will be gathering for our first in-person get-together in Vienna next week. Please excuse any delayed response times as folks zip across the globe! Happy October,\nThe YosysHQ Team\n","date":"2024-10-17T00:00:00Z","image":"http://blog.yosyshq.com/static-2023/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20241017-released/","title":"Tabby CAD Suite version 20241017 released!"},{"content":"The September release of Tabby CAD Suite is now available for download. Notable changes in this version include:\nsynth_nanoexplore adds experimental synthesis support for the NanoXplore NG-Ultra radiation-hardened FPGA family. In other YosysHQ news:\nMatt attended ORConf in Sweden and met with members of the community and YosysHQ customers. All the talks have been published already and we‚Äôre sure you‚Äôll find something that interests you: https://fossi-foundation.org/orconf/2024 Happy September,\nThe YosysHQ Team\n","date":"2024-09-03T00:00:00Z","image":"http://blog.yosyshq.com/static-2023/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20240903-released/","title":"Tabby CAD Suite version 20240903 released!"},{"content":"The August release of Tabby CAD Suite is now available for download in Releases. Notable changes in this version include:\nDocumentation in PDF format is now included with Tabby CAD Suite downloads, in case you are not able to access our online documentation or need to look up an old version. In other YosysHQ news:\nRecordings of the talks at this year\u0026rsquo;s Free Silicon Conference are now online! Check out the opening day keynote from our CSO Matt, or this talk from researchers at ETH Z√ºrich about how to get competitive performance out of the Yosys+OpenRoad ASIC flow. Happy August,\nThe YosysHQ Team\n","date":"2024-08-06T00:00:00Z","image":"http://blog.yosyshq.com/static-2023/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20240806-released/","title":"Tabby CAD Suite version 20240806 released!"},{"content":" # Teaching with Open Source Tools Welcome to another community spotlight article where we shine a light on open source EDA-related projects. If you want to submit a project, please do so here.\nThis post recounts experiences from using the Open Source Tools for teaching! Many people have wondered how stable the tools are and whether they can be used in classes. Here is one experience, from UC Santa Cruz!\n# Dustin Richmond Bio: I am an Assistant Professor of Computer Science and Engineering in the Baskin School of Engineering at UC Santa Cruz. I did my postdoc in the Bespoke Silicon Group at the Paul Allen School of Computer Science at the University of Washington, and earned my Ph.D. with the Kastner Research Group at the University of California, San Diego.\nYou can find more about my research and projects on my website.\n# What motivated you to use the open source tools in teaching? I‚Äôve always been curious about reducing barriers in hardware education. One part of my PhD studied how to make hardware design easier for non-hardware engineers and laypeople. This is a critical challenge we‚Äôre facing today, as we face a workforce shortage in chip design.\nWhen I started at UCSC I asked: ‚ÄúWhat is stopping us from training more hardware engineers?‚Äù. Or alternatively, ‚ÄùHow can we scale hardware design education?‚Äù\nThis is not a universal opinion, but I personally can‚Äôt imagine teaching hundreds of students per quarter (our goal) with vendor tools. They‚Äôre excellent when you‚Äôre an expert, but I like to compare them to a ‚ÄúPoint and Click Adventure Game‚Äù. They‚Äôre complex! I‚Äôm not saying the vendor tools are bad, they‚Äôre just complex to install, maintain, use, and write tutorials. And when you‚Äôre trying to scale limited teaching resources, that complexity has an opportunity cost.\nLogically, that led to the open source tools. They‚Äôre less complex ‚Äì and more transparent.\n# Describe the class that uses these tools. The class I teach is the third course in the Computer Engineering series, and the second in hardware design with Verilog. The first course focuses purely on logic design with structural Verilog. This course introduces behavioral Verilog, verification, and some advanced digital design concepts.\nWe review structural verilog and then move quickly through always blocks, memories, Look-up-Tables, DSPs, Synthesis, Place \u0026amp; Route, Clocking, functional/formal verification. All of the assignments have some sort of implementation demo on the FPGA we use.\n# What tools do you use in your class? Students use Verilator and Icarus Verilog for simulation, Yosys for synthesis, and NextPNR for Placement, Route and STA. Students also use Symbiyosys for formal verification. Students can also use Verilator for linting ‚Äì which I highly encourage. To view waveforms, we use Surfer, or GTKWave. To view schematics we use netlistsvg or the dot files emitted by Yosys.\nIt‚Äôs not critical, but to eliminate tool installation overhead and misconfigurations, this is all distributed in a Dockerfile. The Dockerfile is ingested by GitHub Codespaces, so students can run the tools in the cloud via VSCode. To view waveforms, we use the Surfer VSCode Plugin. The end result is an all-in-one interface using VSCode with zero installation overhead.\nFor implementation, we use the Icebreaker Board with various PMOD peripherals (HDMI, I2S2, Joystick, keypad, Seven-Segment, etc). Not a large board, but we can do streaming audio/video processing.\nFinally, I use cocotb for writing testbenches that test student code. To parameterize tests, I use cocotb-test. This all feeds into an autograder, Gradescope, using a library called pytest_utils. We have an open-source autograder at UCSC that I intend to switch to long term.\n# What is the most surprising thing you‚Äôve learned? The open source tools are stable, at least as stable as the vendor tools. I think this is the most common worry ‚Äì ‚ÄúIf I switch, will it explode?‚Äù. I can confidently say: No. And even better, when they do explode, you (or a TA) can pretty quickly figure out why. We‚Äôve even had a colleague push through a Verilator pull request mid-quarter.\n# What are some of the benefits of switching? # Verification How many people have written a testbench that breaks when they switch computers? Or versions? Or vendors? The downside of using one tool for simulation is that it is very easy to write testbenches in Verilog that are secretly dependent on an internal simulation model. By using two simulators we can highlight how Verilog is evaluated, and how a good, tool-agnostic testbench is constructed.\nIn the class, students spend two weeks writing testbenches. I give them working \u0026amp; buggy code that has been synthesized through Yosys (another benefit). Using testbenches they write, they have to find the working modules and assemble them into a working design.\n# Speed It takes less time to Synthesize, Place, and Route a design than it takes to open some vendor tools. I think this is a critical aspect for exploration. Waiting 5-minutes just to see a light flash is a buzzkill.\n# Introspection This is a pretty universal theme in the tools. Since they‚Äôre open source we can actually see what happens when we simulate, synthesize, place and route, etc. We can even open the algorithms in class and dissect them.\nWith the Lattice FPGAs, it is easier to explain the architecture and then extrapolate to more complex architectures like Intel and AMD.\nThis introspection extends to visualisation. We use yosys to generate schematics and view the .dot files, or use netlistsvg. We can do this at different steps in the flow to see the abstract circuit, and progressively optimize it. We also do this during lab check-off to ensure that students are synthesizing to memories instead of arrays of registers (or something worse).\n# What are some of the drawbacks? # Lack of Legacy The vendor tools have 40-odd years of legacy support. There are entire message boards dedicated to solving issues encountered in every tool vendor. When you do encounter an issue in the vendor tools, it is likely many other people have encountered it, if not solved it.\nThis is changing, and the open source community is great and strong, but 40 years is a lot of ground to make up.\n# Student Resistance Students read job postings, and they want to learn the tools they see in job postings. Our class is titled ‚ÄúLogic Design with Verilog‚Äù, so we can focus on the language, not the tools. But where do we draw that line? We‚Äôre exploring ideas like using vendor tools in the final weeks of the quarter, after they‚Äôve learned the language, or pushing vendor tools to a capstone.\nThis is an active area of discussion. Vendor tools should be part of a computer engineering curriculum. How much? And when?\n# How can the community support you? Come visit UC Santa Cruz! The Hardware Systems Collective has a weekly seminar series and we love hearing about cool open source projects.\n# How can we get in touch? Feel free to email! I am happy to share teaching materials, but they\u0026rsquo;re in repositories, but not in a public form yet.\n","date":"2024-07-17T16:00:00+01:00","image":"http://blog.yosyshq.com/static-2024/spotlight/hsc/hsc.png","permalink":"http://blog.yosyshq.com/p/community-spotlight-teaching-with-open-source-tools/","title":"Community Spotlight - Teaching with Open Source Tools"},{"content":"The July release of Tabby CAD Suite is now available for download. This month\u0026rsquo;s notable changes mainly affect the build process, so are not relevant if you download our binaries. For those of you subscribing to the YosysHQ Verific Patch and building from source:\nWe have reorganized the build flags for compiling with Verific to try to support more flavors of Verific (more documentation to follow). We have tried to keep existing configurations working, but if you encounter any build issues when updating to the latest release, try a full clean (make clean and make clean-abc) and check if you need to set any of the new ENABLE_VERIFIC_* flags in your Makefile.conf. The minimum supported C++ standard version has been updated to C++17. The compiler flags in the Makefile have been changed to reflect this, but if you are manually setting an older flag, you may need to update your configuration. In other YosysHQ news:\nThe recordings of the FPGA Lightning talks from our last Yosys Users Group meeting are now online! Check them out on our youtube channel. Happy July,\nThe YosysHQ Team\n","date":"2024-07-09T00:00:00Z","image":"http://blog.yosyshq.com/static-2023/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20240709-released/","title":"Tabby CAD Suite version 20240709 released!"},{"content":" # MIRMIS The Modular Infrared Molecules and Ices Sensor (MIRMIS) is a hyperspectral infrared imaging instrument set to launch on ESA\u0026rsquo;s Comet Interceptor mission in 2029. Its development is led by the University of Oxford\u0026rsquo;s Professor Neil Bowles (Instrument Lead Scientist) and it has three sensors‚ÄîTIRI (University of Oxford), MIR, and NIR (VTT Finland)‚Äîthat will image a pristine comet to measure its structure, chemical composition, and temperature, allowing researchers to gain insight into the formation of the Solar system.\nThe MIRMIS structural‚Äìthermal model (STM) mounted for vibration testing at 35g in the Space Instrumentation group\u0026rsquo;s vibration test facility.\nThe Space Instrumentation group at the University of Oxford is building the common structures and mechanisms for MIRMIS, building and calibrating the TIRI sensor, integrating the MIR/NIR sensors, and building MIRMIS\u0026rsquo; command and data-handling unit (CDHU). The CDHU is the interface to the spacecraft and is based around a radiation-hard microcontroller and radiation-tolerant FPGA that together process commands from Earth, control pointing mirrors to track the target comet, operate the imaging sensors, and carry out housekeeping over the instrument\u0026rsquo;s multi-year trip through deep space.\nYosysHQ support FPGA development on MIRMIS by providing formal verification tools, including SymbiYosys for safety and liveness property checking and reachability checking.\nLunar Thermal Mapper (launching November 2024 on NASA\u0026rsquo;s Lunar Trailblazer), the previous-generation instrument on which MIRMIS/TIRI is based, shown without its protective covering.\n# Space instruments at Oxford Part of the University of Oxford\u0026rsquo;s Atmospheric, Oceanic, and Planetary Physics (AOPP) sub-department, the Space Instrumentation group and our sister Infrared Multilayer Laboratory have a long history of building science instruments. Our contributions include, among many others:\n2029 ‚Äî Comet Interceptor, MIRMIS, and ARIEL telescope (Sun‚ÄìEarth L2) 2024 ‚Äî PREFIRE, infrared filters (Earth) 2021 ‚Äî James Webb Space Telescope, Mid-Infrared Instrument filters (Sun‚ÄìEarth L2) 2018 ‚Äî InSight, Short-period Seismometer (Mars) 2010 ‚Äî Stratospheric Observatory for Infrared Astronomy, filters (Earth) 2005 ‚Äî Mars Reconnaissance Orbiter, Mars Climate Sounder optics (Mars) 2004 ‚Äî Aura, High-Resolution Dynamics Limb Sounder (Earth) 1997 ‚Äî Cassini-Huygens, Composite Infrared Spectrometer cooler and optics (Saturn) 1989 ‚Äî Galileo, Near-Infrared Mapping Spectrometer (Jupiter) 1978 ‚Äî Pioneer 12, VORTEX (Venus) 1970 ‚Äî Nimbus 4, Selective Chopper Radiometer (Earth) In addition to the work done by the Space Instrumentation group and the Infrared Multilayer Laboratory, the more than 100 members of AOPP research and contribute to the study of exoplanets and planetary physics, atmospheric, climate, and weather theory and modelling, Earth\u0026rsquo;s oceans, and Earth\u0026rsquo;s cryosphere. AOPP is based out of the Clarendon Laboratory in the centre of Oxford, where it has a range of space-related facilities including cleanrooms, a variety of vacuum chambers, metrology, spectroscopy, optics, and vibration-testing facilities, and electronics and mechanical workshops.\nEngineering model (EM) of the focal plane assembly for the CIRS instrument on Cassini-Huygens, which operated in Saturn orbit from 2004 until 2017.\n# Why build MIRMIS? Comets and other interstellar objects can tell us a lot about how our Solar system formed. As they were often ejected a long time ago, they act as a time capsule holding the chemicals and materials that were around in the early Solar system. This means that, if we can accurately measure their properties, we have a direct view into the past. One challenge with this is finding a \u0026lsquo;pristine\u0026rsquo; object‚Äîwe tend to see these objects as they pass through the inner Solar system, where the heat and radiation from the Sun will change them. MIRMIS will be launched as part of Comet Interceptor to the Sun‚ÄìEarth L2 Lagrange point, around 1.5 million kilometres away and where the James Webb Space Telescope is stationed, so that it can move quickly to intercept a pristine comet after it\u0026rsquo;s detected but before it\u0026rsquo;s spent too long transiting the Solar system.\n# What makes you excited about MIRMIS? The MIRMIS instrument is exciting both because of the science data it will produce but also because of the engineering behind it. It continues a process of refining and improving our equipment‚Äîits CDHU and TIRI are evolutions of Lunar Thermal Mapper, while the infrared filters have heritage to Diviner and further back.\nThe technology behind MIRMIS also has the potential to impact life on Earth more directly. One use we\u0026rsquo;ve been exploring is launching a MIRMIS-like instrument to detect wildfires on Earth. The instrument itself is compact (around the size of a large briefcase), weighs around 9kg, and draws around 11W peak. A small constellation could launch on a single rocket and provide multiple observations of the entire surface of the Earth per day, and with the Space Instrumentation group\u0026rsquo;s extensive background in high-resolution infrared imaging the results could exceed current capabilities.\n# What are some of the challenges you face? # There are no debug probes in space Verification and validation are huge parts of building a space instrument. Not only is deep space a radiation-harsh environment but getting there on a rocket puts a lot of forces on the relatively delicate glassware in optical systems and, once you\u0026rsquo;ve launched, there\u0026rsquo;s no replacing a broken part. This is part of our reason for using Yosys and SymbiYosys in particular‚Äîformal verification of the FPGA components gives us a lot more confidence and functional coverage than plain unit tests and testbenches can provide.\n# Space hardware lags the leading edge It takes a lot of time to qualify a part for space, and for integrated circuits they often need to be made with different processes from normal commercial parts. This means that the performance tends to be significantly lower, too. The FPGA in the MIRMIS CDHU, for example, requires more than a little effort to close timing at 100MHz and has no niceties like DSP blocks, large block RAMs, PLLs, high-density logic elements, or extensive IP core libraries. And that\u0026rsquo;s before having to build in triple redundancy and other safeguards against radiation flipping a bit in a register or transiently changing the value on a signal line.\nElectrical functional model (EFM) of the MIRMIS command and data-handling unit.\n# What could the community do to support you? Keep being interested in space and in planetary science. Science is a collaborative endeavour, and the more people we have contributing to and advancing the field the better the results can be for all humanity. And keep developing high-quality, open-source tools to support the science.\n# What is the best link for the project? ESA\u0026rsquo;s Comet Interceptor Red Book is a great deep dive into the mission, including MIRMIS as well as the other instruments.\nIf you\u0026rsquo;re interested in postgraduate study, have a look at our open DPhil projects.\n# Liam McSherry\u0026rsquo;s bio I\u0026rsquo;m an engineer working across electronics, FPGA, and software disciplines. I split my time between the Space Instrumentation group at Oxford, as Principal Engineer currently leading FPGA development on the MIRMIS CDHU, and L3Harris, as a Principal Engineer architecting and helping build high-performance RF and signal-processing systems. In my work I\u0026rsquo;ve had a hand in projects including radio direction-finding systems, control systems for ion-trap quantum computing, GNSS anti-jam/anti-spoof, and both ground and space sides of satellite payloads, as well as delivering talks and training courses on C++, software-defined radios, and FPGAs.\nOutside of work, I like to take a relaxed approach. I read a lot, I cook and bake, and occasionally badly play badminton. Being in Oxford, I like to take advantage of the many green spaces, too.\n# What is the best way for people to contact you? Neil Bowles (Instrument Lead Scientist, MIRMIS): neil.bowles [at] physics.ox.ac.uk Liam McSherry: liam.mcsherry [at] physics.ox.ac.uk ","date":"2024-06-12T16:00:00+01:00","image":"http://blog.yosyshq.com/static-2024/spotlight/mirmis/esa-hero.bmp","permalink":"http://blog.yosyshq.com/p/community-spotlight-mirmis/","title":"Community Spotlight - MIRMIS"},{"content":"The June release of Tabby CAD Suite is now available for download. There are no notable user-facing changes in this version, as our dev team has been mostly busy with a revamp of our CI infrastructure.\nIn other YosysHQ news:\nProf. Andrew Kahng\u0026rsquo;s keynote at the EFCL summer school was on accelerating innovation with open source tools. Of particular interest was using the results from open source tools as a proxy for the proprietary tools. For more info and links to Andrew‚Äôs slides - check Matt‚Äôs report on linkedin. From the 11th to the 13th of June our CEO Nina will be at CERN for the FPGA developers Forum - if you‚Äôre there please say hello. Our CSO Matt will be in Paris at the Free Silicon Conference from the 19th to the 21st of June. If you‚Äôre there come and say hello! For the Yosys User‚Äôs Group #7 we had FPGA lightning talks. Watch them all here. Happy June,\nThe YosysHQ Team\n","date":"2024-06-07T00:00:00Z","image":"http://blog.yosyshq.com/static-2023/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20240607-released/","title":"Tabby CAD Suite version 20240607 released!"},{"content":"The May release of Tabby CAD Suite is now available for download. Notable changes in this version include:\nThe smtbmc engine can now output information on used assumptions in each step, to help debug failing cover properties. To enable this feature, add the --track-assumes option in the [engines] section like this: smtbmc yices -- --track-assumes In other YosysHQ news:\nOur next Yosys Users Group meeting will be FPGA lightning talks! Join us on Monday, May 27th at 18:00 CEST at this link. It is also still possible to submit a talk. Our latest community spotlight is about Manta, a vendor-agnostic logic analyzer and virtual interface for FPGAs. Happy May,\nThe YosysHQ Team\n","date":"2024-05-08T00:00:00Z","image":"http://blog.yosyshq.com/static-2023/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20240508-released/","title":"Tabby CAD Suite version 20240508 released!"},{"content":" # Manta Welcome to another community spotlight article where we shine a light on open source EDA-related projects. If you want to submit a project, please do so here.\nManta is a configurable and approachable tool for FPGA debugging and rapid prototyping. It works by letting you configure cores that you instantiate in your FPGA design, and operate from a host machine connected over either UART or Ethernet. These cores can provide a logic analyzer, or direct access to registers or memory on the FPGA. Manta is written in Python, which allows its host-side to code to run on nearly any platform (including the web!). The code on the FPGA side is written in Amaranth HDL which exports to vendor-agnostic Verilog-2001, allowing it to run on nearly any FPGA.\n# Fischer Moseley\u0026rsquo;s Bio I\u0026rsquo;m a FPGA Engineer working at NASA JPL, currently working on an orbital interferometer mission called GRACE-C. I joined the lab right after getting my Master\u0026rsquo;s degree from EECS from MIT last year, where I helped teach the lab-based FPGA Design Course and wrote the original version of Manta for my thesis. Oh, and I built the (above) electric shopping cart there too. It\u0026rsquo;s awesome. And kinda dangerous.\nI\u0026rsquo;ve worked on Formula cars, quantum computers, robots, and spacecraft, but I have yet to see a field with as much complexity and momentum behind it as the FPGA/SoC/ASIC space. I think there\u0026rsquo;s a lot of work left to do with these devices, and I get a lot of joy from building the tools around them. Manta is one such tool, and I hope you find it useful!\n# What motivated you to make Manta? When we were preparing to teach the FPGA design class at MIT, we noticed that ARM platforms were gaining popularity with students, primarily in the form of Apple Silicon. This was a problem for our EDA tool (Vivado) which, despite our best tricks, was only usable on x86 platforms. To solve this, we developed a tool that ran Vivado remotely, allowing students to build their bitstreams without having the tools installed on their machine. This worked splendidly.\nHowever, this meant that we couldn‚Äôt use Vivado‚Äôs built-in debugging tools such as the Integrated Logic Analyzer (ILA) or Virtual IO (VIO), as these tools require Vivado‚Äôs Hardware Manager to be running on the machine connected to the FPGA. This was a bit of a problem, as students would often connect their FPGAs to external devices for their final projects, and it was nearly impossible to guarantee that those were behaving exactly as they were modeled in simulation.\nManta was written to solve this problem. It provides the same functionality that the ILA and VIO cores provide (and more!) without requiring a specific architecture or OS.\n# What makes you excited about Manta? As I‚Äôve been developing designs at JPL, hacking on personal projects, and engaging with the community, I‚Äôve been amazed at how long Manta tends to stick inside a project. I thought that it would only be useful at the beginning of a project for getting a quick prototype done, or that it‚Äôd only be pulled out to hunt down the occasional bug. However, this hasn‚Äôt been the case from what I‚Äôve seen. After it‚Äôs been included, it usually tends to stay in the design - either to quickly investigate a bug if it comes up again, or to serve as the permanent link between a FPGA and its host machine.\nThis makes me really excited about the need that Manta is fulfilling. But there‚Äôs two features that I‚Äôm also really excited about:\n# Waveform Record/Playback Manta‚Äôs Logic Analyzer allows you to save a captured waveform as a .vcd file, just like any other logic analyzer. However, unlike any other logic analyzer, it lets you save a captured waveform as a Verilog module. When included in a simulation testbench, this module will generate an exact replication of the captured waveform.\nThis is super handy for testing RTL when the exact sequence of inputs it‚Äôll see on the FPGA isn‚Äôt well-known. For example, when testing a network stack deployed to a FPGA, I‚Äôve found that some USB-Ethernet adapters aren‚Äôt entirely compliant with the RMII spec, and emit slightly malformed packets. This wasn‚Äôt modeled in my simulations, but by recording a few malformed packets and playing them in a testbench, I could quickly patch the network stack.\nThis is just one example, but it‚Äôs been extraordinarily useful for hunting down strange hardware bugs like these!\n# Web Terminal Since Manta can communicate with a host machine over UART, it‚Äôs possible to use the Web Serial API to run Manta in the browser, directly from the documentation site:\nAnd here‚Äôs a quick demo of an earlier version in action:\nEverything here is run locally in your browser, no installation required! Nothing is sent to an external server either. I‚Äôm still putting this feature together and it‚Äôs not generally available just yet, but I‚Äôd love any feedback on it - especially if anyone can think of a proper use case for it. Right now I‚Äôm just building this feature to show that it‚Äôs possible, but I‚Äôm happy to direct development in a more productive direction if one exists.\n# What are some of the challenges you face? Getting the backend of the Web Terminal working was a huge challenge! Inside the Web Terminal Manta is being run in its native Python, which relies on blocking (synchronous) IO between the host and FPGA. Javascript in the browser typically uses non-blocking (asynchronous) IO, so this required some gnarly tricks to get working. I had never written a line of Javascript prior to this, so getting this working has been extremely satisfying!\n# What could the community do to support you? Try Manta and talk about it! If there‚Äôs one thing the project needs right now, it‚Äôs a community around it. If folks are making cool projects with Manta, then that‚Äôll grow organically. Even just starring the GitHub repo helps.\nFinancial contributions are also always appreciated and are possible by sponsoring me on GitHub. Right now I‚Äôm looking to purchase some more FPGA development boards to run automated hardware-in-the-loop tests on. If anyone has any Altera, Microchip, ECP5, or Xilinx development boards handy that they‚Äôd consider donating, please reach out!\nLastly, contributions to the source code are extremely welcome. I‚Äôm looking to add cores for AXI, AHB3, Wishbone, and Avalon busses, and help contributing to those would be greatly appreciated.\n# What is the best link for the project? All of the source code is on GitHub, which also serves the documentation site.\n# What is the best way for people to contact you? If you have ideas about Manta, please open a GitHub issue on the repo! Otherwise you can reach me directly at fischer.moseley [at] gmail.com.\nAlso if you like motorized shopping carts and other silly projects, feel free to check out fischermoseley.com or my YouTube channel!\n","date":"2024-04-30T20:30:31+01:00","image":"http://blog.yosyshq.com/static-2024/spotlight/manta/logo.png","permalink":"http://blog.yosyshq.com/p/community-spotlight-manta/","title":"Community Spotlight - Manta"},{"content":"The April release of Tabby CAD Suite is now available for download. Notable changes in this version include:\nVHDL2019 mode is now available with verific -vhdl2019. In other YosysHQ news:\nA major rewrite of the Yosys manual went live recently. Shoutout to our team member Krystine who has been working on this for months and is continuing to make improvements to our documentation! Happy April,\nThe YosysHQ Team\n","date":"2024-04-10T00:00:00Z","image":"http://blog.yosyshq.com/static-2023/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20240410-released/","title":"Tabby CAD Suite version 20240410 released!"},{"content":"The March release of Tabby CAD Suite is now available for download. Notable changes in this version include:\nYou can now query the proof status of properties in a design using sby --status example.sby. This works as soon as any SBY task was launched, so you can use it to query progress while SBY is still running in another terminal. The abc pdr solver now supports continuing to prove other properties after a counterexample is found using abc --keep-going pdr in engines. In other YosysHQ news:\nGabriel Gouvine contributed this guest blog post on logic locking with his Moosic plugin. Happy March, The YosysHQ Team\n","date":"2024-03-16T00:00:00Z","image":"http://blog.yosyshq.com/static-2023/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20240312-released/","title":"Tabby CAD Suite version 20240312 released!"},{"content":" # FazyRV Welcome to another community spotlight article where we shine a light on open source EDA-related projects. If you want to submit a project, please do so here.\nFazyRV is a minimal-area RISC-V core that scales with your needs. It allows you to adapt the data path width to process smaller 1, 2, 4, or 8-bit chunks of the 32-bit operands each clock cycle. In addition, each data path width can be combined with FazyRV\u0026rsquo;s manifold variants to trade area with performance and find the best-fitting configuration for your system requirements and used technology. FazyRV avoids hand optimizations at the gate level to increase readability and ease modifications, such as adding custom instruction extensions.\n# Meinhard Kissich\u0026rsquo;s Bio I am a Ph.D. student at Graz University of Technology in Austria. After completing my Master\u0026rsquo;s degree in Information and Computer Engineering in 2022, I joined the Embedded Architectures \u0026amp; Systems (EAS) Group as a university assistant. My main interests and research areas are RISC-V architectures, FPGA CAD tools, and applied formal verification. I enjoy realizing unique ideas outside convention and evaluating these implementations. For me, it is not just about gathering knowledge but also about sharing it and contributing back to the community. I lead the Real-Time Operating Systems Laboratory course and am always up for discussions and exciting projects.\n# What motivated you to make FazyRV? The fascination of getting the most out of a constrained environment and using even small FPGAs for \u0026ldquo;big\u0026rdquo; projects \u0026ndash; it is like the digital design equivalent of Can it run Doom?. I became captivated by SERV and how small a system-on-chip design can be. However, there was a gap between the 1-bit bit-serial SERV and prevalent 32-bit cores.\nThat brings me to a second point: I wanted to explore how a sub-32-bit core scales between a 1-bit bit-serial and a 32-bit core in terms of area and performance. This is where FazyRV started as a scalable RISC-V core.\n# What makes you excited about FazyRV? FazyRV allows scaling the core to the project\u0026rsquo;s needs in a way that was not available to me before. The fine-grained options can be used to explore the design space and find the best area vs. performance trade-off for the system requirements and target technology. Assume the target technology does not have dual-read-port BRAM primitives available without some area overhead. In this case, you can choose an implementation that serially reads the operands at the expense of one additional clock cycle per instruction. Then, you can synthesize the data path to a width that fits your timing requirements. If it is on edge, you may also experiment with a variant that uses a bypass multiplexer and can save one clock cycle on operand loads. All that is done by just playing around with Verilog parameters.\nLet us delve into a practical implementation by plotting the Mandelbrot set. The comparison below illustrates the performance disparity when using different chunk sizes. While the variant with an 8-bit chunk size delivers the highest performance, it also results in the largest design, as depicted in the plot at the top.\nBut there is more to it: FazyRV avoids hand optimization at the gate level. I want to inspect more closely how synthesis tools optimize the current hardware description and map the patterns.\n# What are some of the challenges you face? One was undoubtedly the architecture of shift instructions. The considered designs significantly influence the resulting area and performance. Finding a suitable trade-off is more challenging when the area and performance overhead must fit all data path widths without getting out of balance.\nAlso, when designing a core highly optimized for area, there are some sacrifices to be made here and there. Of course, the area must be minimized, but likewise, the core must remain suitable for most users and applications when defining constraints in the feature set. One example is the decoder: Not all instruction bits are explicitly checked to reduce the area. Assumptions are made that some instructions cannot occur. The drawback, however, is that an illegal instruction may be interpreted as a different legal instruction instead of raising an illegal instruction exception. In this particular case, it was handled by providing the decoder logic in a table-like format that can be adapted by the user and synthesized to Verilog code by a tool. It eases modifications to detect illegal instructions when required or to add custom instructions to the core without digging into the decoder at a low level. However, many more decisions in the INT and CSR variants are yet to be made.\n# What could the community do to support you? Consider having a play with FazyRV in your next project, either by using the Verilog design directly or exploring FazyRV via LiteX. We are grateful for any opinions, reported issues, or suggestions.\nIf you want to get involved even more, we maintain a list of open topics in the repository. Feel free to use this as a starting point or bring in your own ideas for discussion or a concrete proposed implementation. Even if you are not involved in digital design, well-designed tooling, workflows, and software support are needed to make adopting FazyRV as convenient as possible and verify changes continuously.\n# What is the best link for the project? The GitHub repository is the best place to start. It is where everything comes together and you will find the latest changes and updates. For example, we will soon publish a research paper with many more evaluations and design insights, which we will reference in the repo.\n# What is the best way for people to contact you? You can find a list of up-to-date contact options on my website.\nwww.meinhard-kissich.at ","date":"2024-03-10T20:30:31+01:00","image":"http://blog.yosyshq.com/static-2024/spotlight/fazyrv/fazyrv.png","permalink":"http://blog.yosyshq.com/p/community-spotlight-fazyrv/","title":"Community Spotlight - FazyRV"},{"content":"This guest post is by Aki Van Ness.\n# Sky130 SPICE, the KiCad way Picture this, you\u0026rsquo;re working on a custom layout for Sky130, be it a PLL, or you\u0026rsquo;re just trying your hands at making some basic building blocks. You\u0026rsquo;ve got a plan, and and ready to start laying down some nets, and that\u0026rsquo;s when you must face it, the dreaded xschem!\nAll joking aside, xschem is an incredibly powerful schematic capture system, but that power comes at a cost. xschem is fairly arcane to most, it has some graphical problems, and is just in general really hard to use if you\u0026rsquo;re just starting out which makes rapid iteration difficult.\nEnter KiCad, a robust and Open Source EDA software package, while it is mainly used for PCB layout, we can leverage the schematic capture and built-in SPICE simulation, right?\n# Introducing kicad-pdk-libs A little while ago I ran into that exact problem, and so I set out and made kicad-pdk-libs, a KiCad symbol library that adds schematic symbols for not only the basic building blocks of the Sky130 PDK, but also SPICE library linkage.\nWith this you can do things as simple as just stubbing out a SPICE simulation for some of the primitive gates, or go down to the transistor level and build gates from scratch and simulate their characteristics!\nAs it stands, kicad-pdk-libs has almost 100% complete symbols for both the Sky130A and Sky130B PDKs, all the cell libraries as well as the base sky130_fd_pr primitives library. This allows you to not just put transistor level schematics together, but much larger schematics using all of the pre-made gates and cells in the library, including some SRAM blocks.\n# Quick n\u0026rsquo; Dirty Inverter The basic example that almost everyone uses as their first CMOS device is the trusty inverter. As such we will quickly go over it here, if you wish for a more step-by-step guide with additional details, see the kicad-pdk-libs intro in the docs.\nAll you need to do is to throw a sky130_pfet_01v8 and a sky130_nfet_01v8 on top of each other with their drains facing each other, hook up VCC and GND and then join the gates and drains, and just like that, you have an inverter using the primitive Sky130 FET models.\nNext set up some way to drive the sim, in my case I did a VDC source and then a VPULSE to drive the inverter, these are built-in to the standard KiCad SPICE library, it should look something like this when done:\nAfter that, you can add the following SPICE directives as a text element on the schematic, and make sure to replace ${PDK_ROOT} with the path to your local PDK root:\n.tran 100f 100n .lib ${PDK_ROOT}/sky130A/libs.tech/ngspice/sky130.lib.spice tt And finally, we\u0026rsquo;re ready to run the sim! Open up KiCad\u0026rsquo;s simulation utility and simply click the \u0026ldquo;Run/Stop Simulation\u0026rdquo; button, if all goes well, the simulation will run and then we can plot the A and Y signals.\nLook at that! It\u0026rsquo;s a working inverter!\nSomething important to note, this simulation uses default parameters for the Sky130 transistors, you can get more accurate results by using magic to extract the transistor parameters from a layout and then attach them to the KiCad symbols by setting the Sim.Params property on the transistor.\n# Conclusion I hope this gives you a brief idea of what the kicad-pdk-libs is all about, and how you can use it to simulate your schematics for use in ASIC layout.\nWhile it may not be as powerful and scriptable as something like xschem, especially right out of the box, I hope it is a useful tool for those just starting out, or for people who just need to throw things together quickly. Especially with the promising improvements coming to KiCad 8\u0026rsquo;s simulation workspace, which will allow much more comprehensive and complete analysis.\nIf you\u0026rsquo;re interested in kicad-pdk-libs and what you\u0026rsquo;ve read here, give it an install, and check out the intro and the examples for more detailed information.\nGo have fun and make something cool!\n","date":"2024-02-12T19:09:55-08:00","image":"http://blog.yosyshq.com/static-2024/sky130-kicad/banner.png","permalink":"http://blog.yosyshq.com/p/sky130-kicad-spice/","title":"Sky130 SPICE, the KiCad way"},{"content":"We have recently started a Yosys User\u0026rsquo;s Group. You can see the minutes of our first 4 calls here.\nIf you\u0026rsquo;d like to join, then please sign up to the newsletter or follow us on:\nlinkedin, mastodon or twitter. # YUG 7 - FPGA lightning talks 6 great presentations about open source FPGA projects! Watch the talks here: https://www.youtube.com/watch?v=wZiocG8DHfE\u0026list=PL-ggbobZGIQuMGBkQgubVbJ1jffe2k18O\nThanks to the presenters: Pat Deegan, Frans Skarman, Mart√≠n Heredia, Sasko Simonovski, Christopher Lozinski and Ashe Connor.\n# YUG 6 - Hardware Security Katharina \u0026amp; Flavian from ETH Zurich introduced their tool for Information Flow Tracking: https://comsec.ethz.ch/research/hardware-design-security/cellift/\n# YUG 5 - SystemVerilog with Pulp‚Äôs SVase An introduction to Bender, Morty and SVase # YUG 4 - all the plugins! List of all the plugins we know of Gabriel Gouvine talks about how he wrote a logic locking plugin Martin Povi≈°er talks about the Python plugin API # YUG 3 - pick your primitives! Show in the case of multipliers how one would go about instructing Yosys to synthesize chosen primitives a specific way. https://github.com/povik/yug3_demo # YUG 2 - introducing EQY! A demo of our new formal equivalence tool - eqy. # YUG 1 - a new users group! What people are using Yosys for, How things can be improved, Introducing our new tools, ","date":"2024-02-04T12:00:00Z","image":"http://blog.yosyshq.com/static-2023/yug.jpg","permalink":"http://blog.yosyshq.com/p/yosys-users-group/","title":"Yosys User's Group"},{"content":"This guest post is by Gabriel Gouvine.\n# Applying logic locking to a TinyTapeout design with Moosic When creating a design, most of us are not in possession of the lithography and manufacturing tools necessary to actually create the chip: we send our design to a foundry and they make the chip for us.\nThis requires a great deal of trust in the toolchain and the foundry: a malicious actor could introduce backdoors, or just steal the design to reuse it themselves. For security-conscious designers, countermeasures are necessary.\nOne such countermeasure is logic locking: we are going to lock our design, so that it does not work without a secret key. We do it by adding or changing some gates in the design to use the key: if the key is incorrect, the design behaviour will be completely modified. This is going to make it harder to reuse the design without authorization (you have to find the key) or to introduce backdoors (you have to understand what it does).\nWe built a Yosys plugin to do just that. The plugin provides a logic_locking command that will mangle the design as much as it can.\nTo illustrate, let\u0026rsquo;s make a design on TinyTapeout, lock it and synthesize it all the way to silicon.\n# What is logic locking The goal of logic locking is to make the design unusable without the right key. Usually, we apply it after synthesis, when the design is already mapped to logic gates. Logic locking adds new gates that will change the behaviour of the design unless the right key is provided. Our tool does it by adding Xor and Xnor gates, as shown below, but you can imagine a lot of ways to insert or replace gates. If a 0 is set for a Xor gate, or a 1 for a Xnor gate, the design works as before. It acts as a countermeasure rather than a cryptographic security. Much like software countermeasures it will not stop a determined attacker with unlimited resources, but it\u0026rsquo;s one more thing that an attacker will have to break.\nThe logic locking tool needs to decide where to insert the gates. Its goal is to disrupt the design as much as possible, and ideally make the key hard to guess by running and analyzing the design. The tool will analyze the impact of inserting a locking gate, and pick the places that maximize its estimated security, typically signals that have a large impact on the design\u0026rsquo;s behaviour. Ultimately, it\u0026rsquo;s a tradeoff between security and performance: for security, the more gates you insert the better, but this makes the circuit bigger and slower.\nJust a few percents of the gates locked is almost always enough to completely corrupt the design. We can explore the tradeoff with the plugin. For example, on this benchmark, locking just 13% of the signals breaks all outputs and all testcases:\n# Locking a design We are going to make a toy design to experiment with logic locking. I wrote a counter, that is incremented at each clock cycle where do_incr is set:\nmodule counter ( input wire do_incr, output wire [7:0] data_out, input wire clk, input wire rst_n ); reg [7:0] counter; assign data_out = counter; always @(posedge clk) begin if (!rst_n) begin counter \u0026lt;= 0; end else if (do_incr) begin counter \u0026lt;= counter + 1; end end endmodule We run Yosys with the Moosic plugin. Since logic locking works on a netlist, we first synthesize our counter with the default library:\nread_verilog src/counter.v synth Now we apply locking and save our netlist. To fit in our 8-bit input port, I picked a small 6-bit key. With only 64 possible values, it is easy to brute-force, so make it a lot bigger if you use it in the wild! And don\u0026rsquo;t lose the key.\nlogic_locking -key-bits 6 -key 39 write_verilog src/locked_counter.v Looking at the file, our module is now a netlist with an additional port moosic_key. Following TinyTapeout\u0026rsquo;s philosophy, it all runs as a Github action.\nmodule counter(do_incr, data_out, clk, rst_n, moosic_key); input do_incr; output [7:0] data_out; input clk; input rst_n; input [5:0] moosic_key; # TinyTapeout With TinyTapeout, we can synthesize this design to silicon. We will have to make a wrapper in order to load the key on our design\u0026hellip; and test that our design works as expected when the key is provided. The main project file will be responsible for loading the key. We are going to keep it simple and read the key directly from the primary inputs. On a production design, getting the key in would be part of the boot sequence.\nTo make sure it all works, we wrote a testbench that checks that our counter behaves as expected\u0026hellip; and is indeed broken with the wrong key.\nAnd finally we have the full masks for the design! The code for the TinyTapeout project is available here, and our locked counter will be on the TT06 chip when it tapes out. If you want to go further, have a look at the project page or our Free Silicon Conference presentation.\nFor power users, the plugin provides a lot of additional options to pick your security metrics, or to balance security and performance. Logic locking is an active area of research, and we are happy to provide an open-source tool to apply it to your designs.\n","date":"2024-01-30T12:00:00+02:00","image":"http://blog.yosyshq.com/static-2024/locking.png","permalink":"http://blog.yosyshq.com/p/logic-locking-with-moosic/","title":"Logic Locking with Moosic"},{"content":"The January release of Tabby CAD Suite is now available for download. Notable changes in this version include:\nYou can now pass arguments to tcl scripts from the command line by appending them at the end of the command, separated from the yosys arguments by \u0026ldquo;\u0026ndash;\u0026rdquo;.\nyosys -c script.tcl \u0026ndash; arg1 arg2\nIn other YosysHQ news:\nWe published a new community spotlight by Frans Skarman. Introducing us to Surfer, which is a new web-based waveform viewer with a focus on extensibility and a snappy user interface. We are hiring! If you know anyone currently looking for a job developing EDA tools, let them know about our jobs page. Happy New Year, The YosysHQ Team\n","date":"2024-01-16T00:00:00Z","image":"http://blog.yosyshq.com/static-2023/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20240116-released/","title":"Tabby CAD Suite version 20240116 released!"},{"content":" # Surfer Welcome to another community spotlight article where we shine a light on open source EDA projects. If you want to submit a project, please do so here.\nSurfer is a new waveform viewer with a focus on extensibility and a snappy (optionally keyboard driven) UI. It runs both natively and in web-assembly, so you can try it out right here in the browser at https://app.surfer-project.org. The project is written in rust and while it is still in its early stages, it is usable as a day-to-day wave viewer.\n# Frans Skarman\u0026rsquo;s Bio I am a 5th year PhD student at the department of electrical engineering at Link√∂ping university in Sweden. I\u0026rsquo;m originally a software person, who started off in game development and then descending lower and lower in the tech stack until I reached this wonderful world of hardware. The whole time, i\u0026rsquo;ve been most interested in writing tools; initially game engines instead of games, and now compilers instead of actual hardware design. My main project these days is https://spade-lang.org/ a hardware description language inspired by modern software languages.\nOutside of programming I enjoy some 3d printing, playing flight simulators, as well as sailing or skiing when the weather permits.\nI also need to give credit to Lucas who was featured in the last community spotlight, and my PhD advisor Oscar who have contributed a ton of features and fixes to the project.\n# What motivated you to make Surfer? When building my HDL, Spade, I ran into a problem. With a powerful type system, the bit representation of a signal is often hard to understand, so you need a way to automatically translate the values back into their human-readable representation to effectively debug your designs. While gtkwave has support for custom translation via external programs, it turned out to be quite hard to get right and wasn\u0026rsquo;t as powerful as I wanted. For example, I found no way to translate a value into a list of expandable sub-fields to, for example, expand individual fields of a struct. I was also bothered by small things like how zooming and scrolling works in gtkwave.\nEventually, the question of \u0026ldquo;how hard can it be\u0026rdquo; made me start this project. Luckily, it turns out that with the right libraries, the answer to that question was that it is easier than I thought it would be.\n# What makes you excited about Surfer? Overall, I\u0026rsquo;m very excited about having a mostly solid waveform viewer where I and others can try out new things, both in terms of translations and interface. I do have some favorite features I can touch more on though:\n# Web assembly Perhaps my favorite thing about Surfer right now is that it works almost flawlessly in web assembly. You can see a demo of that at https://app.surfer-project.org. If you have a VCD file to analyse, you can just append that to the URL along with some commands to run when the waveform is loaded, for example https://app.surfer-project.org/?load_url=https://app.surfer-project.org/picorv32.vcd\u0026startup_commands=module_add%20testbench;divider_add%20.;divider_add%20top;module_add%20testbench.top;show_quick_start.\nApart from being a cool tech demo, this also enables some cool workflow in CI/CD. For example, we can augment the tinytapeout test action to link to surfer with the resulting waveform. No longer will you have to re-run your tests locally, or manually download a VCD file to view it in a desktop viewer.\nI\u0026rsquo;m also very happy that going from idea to implementation of the web version took less than a day thanks to the rich rust ecosystem around web assembly.\n# Signal translation As I mentioned earlier, a big motivator for building surfer was being able to get richer translation of Spade types. Even though I had a hacky system for doing that in gtkwave, the Surfer version where you can expand or collapse structs, view individual enum variants and translate sub-fields as you please is a game changer.\nBelow is an image and a quick demo video showing it off Another really cool translator is the RISC-V opcode translator shown below\nI have also done my best to build this translation system to be decoupled from Spade, meaning that anyone could add translation for their own HDLs constructs, or perhaps something completely different, like a translator that splits a stereo audio signal into left and right channels. All that is needed for that is to implement a few methods in a trait\n# Keyboard and mouse gesture based UI As a vim user, I hate reaching for my mouse, so we\u0026rsquo;ve put quite a bit of effort into making surfer usable with just the keyboard. There are some keybindings for normal navigation of course, but most of the happens via a fuzzy matching based command palette, similar to ctrl-p in Visual Studio Code. For tasks where the mouse is more appropriate, like navigating the waveform there is also a mouse gesture based UI. You can see both in action in the video below.\n# Why do you make open source tools? Every time I have to use non-open source software I get frustrated, sometimes because dealing with licenses but often just because the software is missing features or customization options that I want, or because features I rely on get removed in a new version. These frustrations happen less with open source software in my experience. Since I probably wouldn\u0026rsquo;t use a closed source tool myself, I\u0026rsquo;m certainly not going to build one.\nFor surfer in particular, one of the big advantages of open source is that everyone can add their favorite features, whether it is a translator for a new signal format, a new way to render waves or some new way to interact with the program, things that a closed source developer might not have the interest nor resources to implement. After a while, this makes an open source tool feel very complete, because all the small features and fixes have been added.\n# What are some challenges? The biggest challenge in my mind is in UI design. I\u0026rsquo;m not a UI designer, I only took a single course on it during my bachelor, so most of the time I\u0026rsquo;m just winging it. For features I use myself, I at least have some idea of what I want, for feature requests by others I might even have that.\nThere have also been some technical hurdles, primarily because we offload the parsing of wave files to external libraries. For now we only support VCD, but we are working on both decoupling surfer from the VCD library, as well as adding support for other formats, in particular FST.\n# What could the community do to support you? First, give surfer a try. Let us know what you find nice and what could use improvements. Especially as a non-UX person it is invaluable to get feedback from users!\nIf you want to do more, consider contributing the features you think are missing. In particular, small features like a translator for a new bit format, a fix for a small bug you find or perhaps some additional way to zoom or navigate the waveforms. As I said earlier, people contributing these small things are what gives open source software that warm feeling that someone has thought of your particular use case.\nOf course, we\u0026rsquo;re also very happy to accept bigger contributions, like support for loading files from other wave formats or big translators for translating to the native format from some alt-HDL like Amaranth, Chisel or Clash.\n# What is the best link to give for the project? If you want to learn more, see the git repo. You can also try Surfer right in your browser at https://app.surfer-project.org\n# What is the best way for people to contact you? Email: frans.skarman@liu.se Mastodon: TheZoq2@mastodon.social The Spade discord (with a surfer channel): https://discord.gg/hdyGSn8ejw ","date":"2023-11-27T13:26:31+01:00","image":"http://blog.yosyshq.com/static-2023/spotlight/surfer/surfer.png","permalink":"http://blog.yosyshq.com/p/community-spotlight-surfer/","title":"Community Spotlight - Surfer"},{"content":"The November release of Tabby CAD Suite is now available for download. Notable changes in this version include:\nFixed problems with verific elaboration in VHDL that were introduced in the last release - you should no longer see spurious multiple driver warnings. Memory inference can now recognize (* rom_style = \u0026ldquo;\u0026hellip;\u0026rdquo; *) attributes on data output and address signals (attributes on the data storage register still take precedence, but this allows forcing a style e.g. when inferring ROM from a case statement). In other YosysHQ news:\nWe just published a new guest blog post by Theophile Loubiere. He wrote a fun introduction to formal by using SBY to solve a sudoku. Happy November, The YosysHQ Team\n","date":"2023-11-07T00:00:00Z","image":"http://blog.yosyshq.com/static-2023/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20231107-released/","title":"Tabby CAD Suite version 20231107 released!"},{"content":"This guest post is by Theophile Loubiere.\n# Solving a Sudoku with SBY and Formal Verification Recently, I began using SBY to formally verify my designs. You can check out my first attempt on my blog learn-fpga-easily. Formal Verification helps ensure that certain properties of your design always remain true, such as:\nBus arbitration: \u0026ldquo;Only one master can receive the bus grant at any given time.\u0026rdquo; Overflow and Underflow: \u0026ldquo;The FIFO buffer will never overflow or underflow.\u0026rdquo; State Machine Reachability: \u0026ldquo;The state machine can never transition from state_1 to state_3.\u0026rdquo; These kinds of properties would normally require an extensive functional testbench for coverage. However, with formal verification and SBY, they can be easily addressed with just a few assertions and assumptions.\nGiven my newfound knowledge, it seemed completely natural that after embarrassingly failing to solve a Sudoku puzzle with my grandfather ‚Äì a hit to my pride ‚Äì I decided to repurpose the use of SBY just to figure out a Sudoku solution.\nToday, I am excited to share with you my overkill attempt to solve a simple Sudoku puzzle with SBY and Formal Verification.\n# Modeling the Sudoku In Verilog, we can represent a Sudoku grid straightforwardly: a two-dimensional register encompassing 9 rows and 9 columns, where each cell occupies 4 bits:\nmodule sudoku ( input clk, ); // Internal 9x9 grid to make operations more intuitive (* keep *) reg [3:0] sudoku_grid[8:0][8:0]; `ifdef FORMAL // see next section `endif endmodule Using the (* keep *) attribute ensures our register won\u0026rsquo;t be discarded during synthesis, even if it isn\u0026rsquo;t used anywhere.\nAnd that\u0026rsquo;s it! Now, let\u0026rsquo;s dive into the interesting part: Formal Verification.\n# How to solve a sudoku with Formal Verification ? Formal verification involves setting specific properties that your design must always satisfy. The formal solver then evaluates a vast array of mathematically choosen scenarios. If a property doesn\u0026rsquo;t always hold true, the solver will tell you: \u0026ldquo;Nope, your property does not hold true in this counter-example.\u0026rdquo;\nBut here\u0026rsquo;s the catch: If we lay down just one property, the solver might churn out a completely irrelevant solution. Take Sudoku: Every row in a correctly solved grid has every digits from 1 to 9. One obvious property is the sum of digits in a row totaling 45 (because 1+2+3+\u0026hellip;+9=45). Yet, with just this, the solver might suggest a row like: 0,0,0,0,0,0,0,0,45. Clearly flawed, given illegal numbers and the repetition.\nWe must assume additional properties to narrow down the solution space and obtain relevant counterproofs:\nIn digital design, we assume valid input behavior, focusing assertions on internal and output signals. For this Sudoku escapade, where we\u0026rsquo;re playfully repurposing the tool, assumptions will lean on the sudoku_grid register (typically a target for assertions). So, what assumptions should we make for Sudoku? The basic rules.\n# Assuming the Basic Rules All digits should be between 1 and 9. Which translates to: `ifdef FORMAL // variables declaration for all forloops genvar box_row, box_col, i, j, k, m, n; // assume all the digits are between 1 and 9 generate for(i = 0; i \u0026lt; 9; i = i + 1) begin : digit_assumption_i for(j = 0; j \u0026lt; 9; j = j + 1) begin: digit_assumption_j always @(posedge clk) begin assume(sudoku_grid[i][j] \u0026lt;= 4\u0026#39;d9); assume(sudoku_grid[i][j] \u0026gt;= 4\u0026#39;d1); end end end endgenerate With these assumptions, the solver won\u0026rsquo;t try any numbers that are outside of this range.\nAll digits in a row are all different generate for(i = 0; i \u0026lt; 9; i = i + 1) begin: row_check for(j = 0; j \u0026lt; 9; j = j + 1) begin: column_j for(k = j + 1; k \u0026lt; 9; k = k + 1) begin: column_k always @(posedge clk) begin assume(sudoku_grid[i][j] !== sudoku_grid[i][k]); end end end end endgenerate All digits in a column are all different generate for(i = 0; i \u0026lt; 9; i = i + 1) begin: column_check for(j = 0; j \u0026lt; 9; j = j + 1) begin: row_j for(k = j + 1; k \u0026lt; 9; k = k + 1) begin: row_k always @(posedge clk) begin assume(sudoku_grid[j][i] !== sudoku_grid[k][i]); end end end end endgenerate All digits in a box are all different generate for(box_row = 0; box_row \u0026lt; 3; box_row = box_row + 1) begin: box_row_check for(box_col = 0; box_col \u0026lt; 3; box_col = box_col + 1) begin: box_col_check for(i = 0; i \u0026lt; 3; i = i + 1) begin: row_i_check for(j = 0; j \u0026lt; 3; j = j + 1) begin: col_j_check for(m = 0; m \u0026lt; 3; m = m + 1) begin: row_m_check for(n = 0; n \u0026lt; 3; n = n + 1) begin: col_n_check // Make sure we\u0026#39;re not comparing the same cell to itself if(i !== m || j !== n) begin always @(posedge clk) begin assume(sudoku_grid[(3*box_row)+i][(3*box_col)+j] !== sudoku_grid[(3*box_row)+m][(3*box_col)+n]); end end end end end end end end endgenerate The initial grid cannot be changed. // assume the intial grid always @(posedge clk) begin : initialization //line 1 assume(sudoku_grid[0][0]==5); assume(sudoku_grid[0][2]==7); assume(sudoku_grid[0][3]==2); assume(sudoku_grid[0][7]==9); //line 2 assume(sudoku_grid[1][2]==6); assume(sudoku_grid[1][5]==3); assume(sudoku_grid[1][6]==7); assume(sudoku_grid[1][8]==1); //line 3 assume(sudoku_grid[2][0]==4); assume(sudoku_grid[2][7]==6); //line 4 assume(sudoku_grid[3][0]==1); assume(sudoku_grid[3][3]==4); assume(sudoku_grid[3][4]==9); assume(sudoku_grid[3][8]==7); //line 5 assume(sudoku_grid[4][3]==5); assume(sudoku_grid[4][5]==8); //line 6 assume(sudoku_grid[5][0]==8); assume(sudoku_grid[5][4]==2); assume(sudoku_grid[5][5]==7); assume(sudoku_grid[5][8]==5); //line 7 assume(sudoku_grid[6][1]==7); assume(sudoku_grid[6][8]==9); //line 8 assume(sudoku_grid[7][0]==2); assume(sudoku_grid[7][2]==9); assume(sudoku_grid[7][4]==8); assume(sudoku_grid[7][6]==6); //line 9 assume(sudoku_grid[8][1]==4); assume(sudoku_grid[8][5]==9); assume(sudoku_grid[8][6]==3); assume(sudoku_grid[8][8]==8); end # Using SBY to solve the Grid With the game rules handed over to our solver, we want it to return the solution now.\nAs highlighted before, in a correctly solved Sudoku, every row, column, or box\u0026rsquo;s digit sum is 45. We simply need to request an example where this property holds true. And since there\u0026rsquo;s only one such example, it elegantly unfolds as our desired Sudoku solution.\n// Ask SBY to explicitly cover the (only) case where sum=45s wire [5:0] sum; assign sum = sudoku_grid[0][0] + sudoku_grid[0][1] + sudoku_grid[0][2] + sudoku_grid[0][3] + sudoku_grid[0][4] + sudoku_grid[0][5] + sudoku_grid[0][6] + sudoku_grid[0][7] + sudoku_grid[0][8]; always @(*) begin cover(sum==6\u0026#39;d45); end `endif FORMAL endmodule # Let\u0026rsquo;s run the verification To install SBY and all the required formal solvers, I recommend following the straightforward installation process provided by oss-cad-suite.\nTo execute the verification, we\u0026rsquo;ll need our sudoku.v file and a SBY configuration file named sudoku.sby with the content below:\n[options] mode cover [engines] smtbmc [script] read -formal sudoku.v prep -top sudoku [files] sudoku.v All we have to do is run the following command :\nsby -f sudoku.sby And as you can see\u0026hellip; it fails\u0026hellip; WAIT! WHAT?\nSBY log\n\u0026ldquo;Unreached cover statement\u0026hellip;\u0026rdquo; What does that mean?\nThe line assumptions are correct. The row assumptions are correct. The box assumptions are correct. The\u0026hellip; line 2 of the initialization is wrong\u0026hellip; assume(sudoku_grid[1][5]==3); // wrong assume(sudoku_grid[1][4]==3); // correct When I visited my grandfather, I handed him the original and copied it onto a paper to solve it myself\u0026hellip; I made a copying error(deep breath)\u0026hellip; At least we stumble upon a unexpected feature : we now know how to identify an unfeasible grid !\nNow, after correcting my mistake, it works as expected: SBY generates the solution for me!\nHere\u0026rsquo;s the solution viewed through gtkwave (SBY give you the path of the vcd file): GTKWave screenshot\nHmm\u0026hellip; that\u0026rsquo;s not very user-friendly to interpret.\nLet\u0026rsquo;s take the futility of this exercise a step further and craft a Python script to visualize the solution. I\u0026rsquo;ve employed the pyDigitalWaveTools Python library to convert my VCD file into JSON format and have requested ChatGPT to create a script that reads the JSON and displays the solution in my terminal. All the sources can be accessed my github page.\nNow, the moment we\u0026rsquo;ve all been waiting for - the solution:\n5 1 7 | 2 6 4 | 8 9 3 9 2 6 | 8 3 5 | 7 4 1 4 8 3 | 9 7 1 | 5 6 2 --------------------- 1 3 5 | 4 9 6 | 2 8 7 7 9 2 | 5 1 8 | 4 3 6 8 6 4 | 3 2 7 | 9 1 5 --------------------- 3 7 8 | 6 4 2 | 1 5 9 2 5 9 | 1 8 3 | 6 7 4 6 4 1 | 7 5 9 | 3 2 8 # Conclusion Let\u0026rsquo;s wrap this up. First off, if you\u0026rsquo;re ever stuck on that pesky Sudoku during a lazy Sunday afternoon, you now know there‚Äôs a\u0026hellip; let\u0026rsquo;s call it an ‚Äúalternative‚Äù way to crack it. And check it is actually feasible.\nNow, on the real note: diving into techy stuff using simple problems we already know? It\u0026rsquo;s golden! It‚Äôs like trying to learn a new dance step with a song you already love. You get the hang of it faster and, more importantly, it\u0026rsquo;s fun. Playing around with SBY in this wild way just shows how cool and flexible these tools can be.\nBig Thanks to YosysHQ for letting me write on their blog. And to you, dear reader, remember: mix things up, try the unexpected, and most importantly, have some fun while you‚Äôre at it. Till next time!\n","date":"2023-11-06T12:00:00+02:00","image":"http://blog.yosyshq.com/static-2023/cover_sby_sudoku.png","permalink":"http://blog.yosyshq.com/p/solving-sudoku-with-sby/","title":"Solving a Sudoku with SBY and Formal Verification"},{"content":"The October release of Tabby CAD Suite is now available for download. Notable changes in this version include:\nImproved identifier resolution when using bind statements in mixed-language projects Respect memory access order semantics when inferring memories with the verific frontend (for simultaneous read and write operations of the same memory location in the same clock cycle, on the same or a different port) Preview builds of our upcoming formal tools ivy and scy In other YosysHQ news:\nWe just published the 4th in our series of ‚Äòcommunity spotlight‚Äô blog posts. This time we‚Äôre featuring WAL by Lucas Klemmer. WAL aims to make it easier to analyze complex waveforms. Happy October, The YosysHQ Team\n","date":"2023-10-11T00:00:00Z","image":"http://blog.yosyshq.com/static-2023/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20231011-released/","title":"Tabby CAD Suite version 20231011 released!"},{"content":" # WAL Welcome to another community spotlight article where we shine a light on open source EDA projects. If you want to submit a project, please do so here.\nWaveform Analysis Language (WAL) is a programming language for complex waveform analysis and EDA tool development.\n# Lucas Klemmer\u0026rsquo;s Bio I\u0026rsquo;m a PhD student at the Institute for Complex Systems at the Johannes Kepler University in Linz, Austria. I received my Master‚Äôs degree in computer science from the University of Bremen in Germany. My interests include RISC-V, HW verification and analysis, kayaking, and learning (natural) languages.\n# What motivated you to make WAL? Waveforms contain so much interesting information; however, this information is ‚Äúburied‚Äù in enormous amounts of data. Using general purpose languages can quickly become challenging to analyze waveforms because these languages have no concepts of time, design structure, and other things we in hardware care about. With WAL, we want to make it easy to analyze waveforms by integrating those concepts into the language to make it ‚Äúhardware aware‚Äù. Simply speaking, a WAL program runs on your waveform, and you can use the waveform signals just like you use variables.\n# Why do you make open source tools? As a computer scientist coming to the hardware world, it was quite a culture shock when I had to use closed-source toolchains. However, in the last few years, this feeling changed from being shocked to being amazed by all the open-source hardware and EDA projects that emerged. With WAL, I hope that I can add my small contribution to this change!\n# What are some challenges? Handling very large waveforms with WAL is possible, but more work on performance and optimizations is required. Moreover, the hardware domain requires a bit more work to win people for new ideas than in the software world.\n# What could the community do to support you? I\u0026rsquo;m constantly looking for interesting new applications. So if you have a waveform and would like to know more about it, then feel to contact me, I\u0026rsquo;m happy to help!\n# What is the best link to give for the project? https://wal-lang.org/\n# What is the best way for people to contact you? Email: lucas.klemmer@jku.at Mastodon: @lcsklmmr@fosstodon.org ","date":"2023-09-25T13:26:31+01:00","image":"http://blog.yosyshq.com/static-2023/spotlight/wal-pipeline.png","permalink":"http://blog.yosyshq.com/p/community-spotlight-wal/","title":"Community Spotlight - WAL"},{"content":"The September release of Tabby CAD Suite is now available for download. Notable changes in this version include:\nTabby CAD Suite now optionally supports floating licenses via FlexLM. Floating licenses are priced at 600‚Ç¨/month (double the price of node-locked licenses). Existing customers may exchange two node-locked licenses for one floating license - please contact us if this would be of interest to you. In other YosysHQ news:\nYosysHQ\u0026rsquo;s Matt Venn will be at ORConf 2023 in Munich next week (September 15th to 17th). If you are also attending, come say hi! Happy September, The YosysHQ Team\n","date":"2023-09-05T00:00:00Z","image":"http://blog.yosyshq.com/static-2023/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20230905-released/","title":"Tabby CAD Suite version 20230905 released!"},{"content":"The August release of Tabby CAD Suite is now available for download. Notable changes in this version include:\nThe verific command now has a new option -lib to load all modules from the specified files as blackbox modules, disregarding their contents. This is useful especially for loading primitives from a simulation library, e.g.: verific -sv -lib cells_sim.v verific -work unisim -vhdl -lib unisim_VCOMP.vhd The files still need to be parseable by verific, so some limitations remain on the contents of the blackboxed modules, but it is possible to ignore some errors by first calling verific -set-warning VERI-XXXX for the corresponding error code.\nIn other YosysHQ news:\nOur newest blog post explores another one-line yosys solution, this time for a problem with non-alphanumeric characters in netnames YosysHQ was present at the Free Silicon Conference at Sorbonne University in Paris in July, check out the recordings of Nina\u0026rsquo;s talk online Happy August, The YosysHQ Team\n","date":"2023-08-07T00:00:00Z","image":"http://blog.yosyshq.com/static-2023/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20230807-released/","title":"Tabby CAD Suite version 20230807 released!"},{"content":"Scenario: you\u0026rsquo;re developing some Verilog RTL and after synthesis the ASIC tools you\u0026rsquo;re using fail on the design! It won\u0026rsquo;t accept square brackets in the input!\nHere\u0026rsquo;s the DUT:\nmodule test( input wire [7:0] a, input wire [7:0] b, output wire [8:0] sum ); assign sum = a + b; endmodule module gen( input wire [23:0] a, input wire [23:0] b, output wire [26:0] c, ); genvar i; generate for (i=0; i\u0026lt;=2; i=i+1) begin test test ( .a (a[i*8+:8]), .b (b[i*8+:8]), .sum (c[i*9+:9]) ); end endgenerate endmodule And here we see the square brackets in the output:\nyosys -qp 'read_verilog generate.v; prep -top gen; write_verilog out.v' grep test out.v test \\genblk1[0].test ( test \\genblk1[1].test ( test \\genblk1[2].test ( Your challenge is to write a yosys one liner that renames the generated module names so they no longer contain square brackets.\nOur solution is:\nyosys -p 'read_verilog generate.v; prep -top gen; rename -hide */c:*[*; rename -enumerate -pattern bracket_% */c:$auto$rename*; write_verilog out.v' grep test out.v test bracket_0 ( test bracket_1 ( test bracket_2 ( If you want to find out more about the Yosys rename command, please read the documentation here.\n","date":"2023-06-12T16:52:39+02:00","image":"http://blog.yosyshq.com/static-2023/oneliners.jpeg","permalink":"http://blog.yosyshq.com/p/yosys-one-liners-rename/","title":"Yosys One Liners - Rename"},{"content":"The June release of Tabby CAD Suite is now available for download. Notable changes in this version include:\nThe RISC-V Formal Verification Toolbox has gained a bus interface for checking that instructions relating to memory result in matching bus transactions, as well as some checks for the machine-mode CSRs required by the RISC-V privileged specification. In other YosysHQ news:\nYou might have seen Bruno Levy‚Äôs excellent introduction to RISCV on an FPGA. In our most recent blog post, guest author Bastian L√∂her shows how he followed the tutorial using Amaranth instead of Verilog. Nina \u0026amp; Matt will be attending the Free Silicon Conference in July. Matt will be attending the RISCV summit hardware track this Friday 9th June. Happy June, The YosysHQ Team\n","date":"2023-06-06T00:00:00Z","image":"http://blog.yosyshq.com/static-2023/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20230606-released/","title":"Tabby CAD Suite version 20230606 released!"},{"content":"This guest post is by Bastian L√∂her.\n# How I went from blinker to RISC-V in 3 months How does one get started with programming FPGAs (field-programmable gate arrays)? Where does one even begin? Also, if you\u0026rsquo;ve ever wondered how a CPU works and how you can build your own, keep reading!\nTL;DR: Getting into FPGA programming nowadays isn\u0026rsquo;t hard anymore. Get a cheap board with at least one LED that is supported by an open toolchain, search for a tutorial, and get that LED blinking!\n# Introduction As an experimental physicist, I have been working with FPGAs for many years. These versatile devices enable creating customized electronics for all kinds of applications. FPGAs typically contain thousands of mostly simple logic units that can be connected in sophisticated ways using a hardware description language (HDL). I have experience writing efficient software for low-latency embedded processors and have so far only made small adjustments to existing VHDL or Verilog projects. However, only recently have I had the opportunity to take a deeper dive into writing new logic designs from scratch.\nIt does not feel that long ago that FPGA boards were prohibitively expensive devices, and the tools and IP cores were not accessible to everyone. Starting development for FPGAs used to be a costly investment and close to impossible to do on a small budget. Luckily, this situation has changed. Small FPGA chips now sell for as low as $10, and a lot of development is done on free and open-source toolchains. As it turns out, with enough ambition and a bit of courage, one can achieve reasonable results in FPGA-land today without breaking the bank!\n# First, find a project For me, it all started with a new project that involved creating a device capable of measuring arrival time and length of logic signals with sub-nanosecond precision. The idea was to create a low-cost spectrometer for measuring high-intensity gamma radiation and replacing the commonly used ADC (analog-to-digital converter) circuit with a TDC (time-to-digital converter) implemented in an FPGA. So, instead of measuring the amplitude of the signal, only the time the signal spends above a certain threshold (time-over-threshold) is measured. This design reduces the system complexity but requires custom logic.\n# Choose your tools I have seen many projects written in VHDL and Verilog, but for this one, I wanted to try one of the new HDL alternatives. My language of choice happened to be the Python-based Amaranth HDL (formerly known as nMigen), primarily because I had in mind to write the accompanying firmware for the device in MicroPython. I was also intrigued by Clash and SpinalHDL, but Amaranth seemed to have an easier learning curve. So, with the clear goal of creating a working TDC, I jumped headfirst into writing Amaranth code. Over the course of the next year (where I spent most of the time on system design and writing software), I became more familiar with the language and successfully finished the project on time for our customer.\n# Set priorities While I was working on the project, I encountered many excellent resources and introductory courses for FPGA programming and logic design, and I read various code examples in different HDLs. I also questioned whether Amaranth was the right choice or if I should have chosen a more conventional language. One tutorial that particularly captured my attention was Bruno Levy\u0026rsquo;s \u0026ldquo;Blinker to RISC-V\u0026rdquo;. The concept intrigued me; one starts with an innocent and all-too-familiar \u0026lsquo;blinky\u0026rsquo; example but ends up with a fully functional RISC-V CPU that can run code written by someone else. Following the tutorial for just 24 steps (the CPU executes the first code after step 7), I was curious to try it out immediately. However, I set it aside during the TDC project and only returned to it afterward.\n# Define your goals At that point, I had enough experience with Amaranth to tackle the tutorial as a practice exercise. Instead of using verilog, I followed Bruno\u0026rsquo;s tutorial in Amaranth HDL, using the open-source F4PGA (formerly Symbiflow) toolchain and an FPGA board that was not supported in the tutorial (Digilent CMOD A7 with Xilinx Artix 7). I wanted to see how far I could go and was unaware of the obstacles that lay ahead.\nDigilent CMOD A7 FPGA board with Xilinx Artix7. USB-UART dongle in the back.\n# And get going! I started the course in December 2022 and published the first version, including step 18 (mandelbrot generator), by the end of February 2023. Here are some of the things I learned during these three months: even though I had used Amaranth HDL before, I needed to learn a few more tricks to translate the tutorial code. I learned how valuable instant feedback through test benches and simulations can be. Most of the time, if the simulated logic was working correctly, the hardware implementation was doing the right thing. I had long wondered what makes a CPU a CPU: what are the essential parts, and how do they all work together to execute a set of instructions and manipulate memory and/or pixels on the screen?\nThis is the question that the tutorial answered in great detail in the first 18 steps and unraveling the mystic black box that a CPU usually is, contributed to at least half the joy I experienced while putting together my own CPU. Bruno explains the RISC-V ISA and ABI, and together we build a more and more capable version of the processor step-by-step. At the same time, I learned the corresponding assembly language for RISC-V, which is essential for testing and programming the CPU at every step. The later steps focus on compiling third-party code with GCC and how to configure the linker so that code is executed from the correct piece of memory in the FPGA. I also learned a lot about compiled objects and ELF formats, which one usually doesn\u0026rsquo;t have to worry about when compiling for Linux-based systems.\n# There\u0026rsquo;s more to it! In addition to the obvious takeaways, there were also several unexpected events that occurred along the way. One significant obstacle was that Bruno\u0026rsquo;s tutorial came with a custom RISC-V assembler, written in Verilog, which assembled the instructions while compiling or simulating the logic. This meant that I had to figure out how to seamlessly integrate it with Amaranth. Moreover, I had to fill in jump offsets manually, which is not very convenient. To streamline the process, I went on a longer tangent to implement the assembler in Python. It was a challenging task, but I succeeded in achieving seamless integration with Amaranth, without the need for manual jump offsets. At a later step, Bruno incorporates the tiny UART sender by Olof Kindgren, I successfully ported it to Amaranth as well, which was a pleasant surprise since it almost worked on the first try.\nHowever, when I attempted to compile for the FPGA boards I had on hand, I realized that they were not supported by the amaranth-boards repository. Fortunately, I was able to modify a similar board description with the help of the reference manual for my hardware (and even get the code merged in time for this post). Meanwhile, I also discovered and fixed a bug in Amaranth itself, as well as some typos in Bruno\u0026rsquo;s tutorial. On more than one occasion I found out that I can effectively discover my own bugs by actually executing code on the CPU. I also learned how to use many great tools, such as Yosys, openFPGAloader, GTKWave, Verilator, and Edalize.\nI\u0026rsquo;m currently working through the last parts of Bruno\u0026rsquo;s tutorial, and while I still have a few steps to go, I\u0026rsquo;ve already learned a lot. Converting the examples to Amaranth HDL has been challenging, but not impossible. Personally, I enjoy working with Amaranth because its semantics are clear and it offers the full power of Python when needed. While some things are more verbose in Amaranth (such as Mux() and Repl()) than their Verilog counterparts, others can be written more concisely.\n# I could not have done it alone During the process, I\u0026rsquo;ve had many questions about Amaranth, the build system, the toolchain, and the hardware. Luckily, the helpful community on IRC (#amaranth-lang on libera.chat) and GitHub has always been quick to respond. Additionally, documentation for open toolchains and developing with these tools has greatly improved in the past year.\nStill, some endurance is needed to pull through, when things don\u0026rsquo;t work as expected. For example, my board and one of my chips were not supported by Amaranth, and I encountered issues compiling on an older laptop with an unsupported 32-bit host architecture. I also found myself in python package hell on more than one occasion. And as they say, the devil is in the details, since some seemingly small steps have taken considerably more time than anticipated (\u0026ldquo;proceed after you have a working RISC-V assembler\u0026rdquo;, \u0026ldquo;we\u0026rsquo;ll use this existing UART module\u0026rdquo;, \u0026ldquo;now just convert the ELF to HEX format\u0026rdquo;).\n# Final thoughts Despite these challenges, my plan is to continue with the tutorial and get the SPI interface working. In the meantime, I\u0026rsquo;m also working on getting support for the free Gowin toolchain (project apicula) into Amaranth\u0026rsquo;s build system. Looking ahead, I\u0026rsquo;m excited to apply the things I\u0026rsquo;ve learned from (not strictly) following Bruno\u0026rsquo;s tutorial to other projects. I\u0026rsquo;d also encourage anyone interested in these concepts to take their favorite HDL and port the tutorial. For me, this has been a great experience, and I\u0026rsquo;m certain that with a growing user base, FPGA design will become even more accessible than it is today!\n# About the author Dr. Bastian L√∂her (Twitter: @y__, Mastodon: @bl0x@mastodon.social) ported Bruno Levy\u0026rsquo;s FPGA tutorial to Amaranth HDL. He is a physicist and control systems engineer for nuclear physics experiments with heavy ion beams. He designs efficient data acquisition software for large heterogeneous particle detection systems and builds mobile radiation sensors for fun.\n","date":"2023-05-15T12:00:00+02:00","image":"http://blog.yosyshq.com/static-2023/blinker-to-riscv.jpg","permalink":"http://blog.yosyshq.com/p/blinker-to-risc-v/","title":"How I went from blinker to RISC-V in 3 months"},{"content":" # AutoSVA Welcome to another community spotlight article where we shine a light on open source EDA projects. If you want to submit a project, please do so here.\nAutoSVA makes Formal Property Verification (FPV) more accesible for hardware designers.\n# Marcelo Vera\u0026rsquo;s Bio Marcelo is a PhD candidate in the Department of Computer Science at Princeton University advised by Margaret Martonosi and David Wentzlaff. He received his BSE from University of Murcia. Marcelo is interested in hardware innovations that are modular, to make SoC integration practical. His research focuses on Computer Architecture, from hardware RTL design and verification to software programming models of novel architectures. He has previously worked in the hardware industry at Arm, contributing to the design and verification of three GPU projects, and at Cerebras Systems, creating High-Performance Computing kernels. At Princeton, he has contributed in two academic chip tapeouts that aims to improve the performance, power and programmability of several emerging workflows in the broad areas of Machine Learning and Graph Analytics.\n# What was your motivation in making AutoSVA? AutoSVA was build with the goal of making Formal Property Verification (FPV) more accesible for hardware designers. AutoSVA brings a simple language to make annotations in the signal declaration section of a module interface. This enables us to generate FPV testbenches that check that transactions between hardware RTL modules follow their interface specifications. It does not check full correctness of the design but it automatically generate liveness properties (prevent duplicated responses, prevent requests being dropped) and some safety-relate properties of transactions, like data integrity, transaction invariants, uniqueness, stability\u0026hellip;\n# Why do you develop open source tools? As the title of our paper suggests \u0026ldquo;Democratizing Formal Verification of RTL Module Interactions‚Äù the motivation on making the tool was to make FPV more accesible for hardware designers without much prior knowledge in formal methods. Thus, open-sourcing makes the most sense when the goal is to get people to use your tool.\n# What are some of the challenges you face? Hardware RTL projects can be very heterogeneous, I made the language and tool pretty flexible to take any Verilog or SystemVerilog, but I wouldn‚Äôt be surprise it the tool complained about some syntax or some include files. The tool also has a way to set inlcude paths on the tool command line, but you never know!\n# What could the community do to support you? I would be happy if the community would keep using it, find limitations, and extend the tool. There are plenty of opportunities to add functionality. I‚Äôm working myself on an extension to automatically find timing channels via hardware state left unflushed between context switches. Stay tuned for updates, Use the tool and contribute back, I‚Äôm happy to take pull requests!\n# What is the best link for the project? https://github.com/PrincetonUniversity/AutoSVA\n# What is the best way for people to contact you? Email: movera@princeton.edu LinkedIn: https://www.linkedin.com/in/marcelo-orenes-vera-391390b8/ ","date":"2023-05-10T13:26:31+01:00","image":"http://blog.yosyshq.com/static-2022/spotlight/spotlight.png","permalink":"http://blog.yosyshq.com/p/community-spotlight-autosva/","title":"Community Spotlight - AutoSVA"},{"content":"The May release of Tabby CAD Suite is now available for download. Notable changes in this version include:\nThe synthprop pass was added, which converts SVA assert properties into module outputs that flag assertion violations. See help synthprop for details! In other YosysHQ news:\nWe just published the 3rd in our series of ‚Äòcommunity spotlight‚Äô blog posts. This time we‚Äôre featuring AutoSVA by Marcelo Vera which aims to make Formal Property Verification more accessible to hardware designers. Happy May, The YosysHQ Team\n","date":"2023-05-09T00:00:00Z","image":"http://blog.yosyshq.com/static-2023/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20230509-released/","title":"Tabby CAD Suite version 20230509 released!"},{"content":"The AXI spec says \u0026ldquo;On Manager and Subordinate interfaces, there must be no combinatorial paths between input and output signals.\u0026rdquo; If we have a design containing an AXI Manager or Subordinate as netlist (i.e. post proc) and the AXI ports contain axi_ we can check this automatically using this Yosys one liner:\nflatten; select -assert-none i:*axi_* %coe* o:*axi_* %cie* %i If that fails we can use show i:*axi_* %coe* o:*axi_* %cie* %i to then see the combinational path (or using dump/printattrs/select -list instead of show when the design is too large for show).\nHere i:*axi_* %coe selects the combinational output cone of all input ports containing axi_ and o:*axi_* %cie* selects the combinational input cone of all output ports containing axi_ and %i takes the intersection of those two selections, leaving you with only the combinational paths that start and end in such an input/output.\nWe also flatten the design, as selecting input/output cones doesn‚Äôt work across submodules.\nIf you want to find out more about the Yosys select command, please read the documentation here.\n","date":"2023-04-17T13:25:38+02:00","image":"http://blog.yosyshq.com/static-2023/oneliners.jpeg","permalink":"http://blog.yosyshq.com/p/yosys-one-liners-axi/","title":"Yosys One Liners - AXI"},{"content":"Tabby CAD Suite version 20230414 released!\nThe April release of Tabby CAD Suite is now available for download. Notable changes in this version include:\nThe initial release of our new equivalence checking tool EQY is now available. Try out some of the examples! In other YosysHQ news:\nWe have started a new series called ‚ÄòYosys One Liners‚Äô where we share some useful one liners. The first one shows how to show there are no combinatorial paths between input and output signals - useful for verifying correct AXI behaviour. Happy April, The YosysHQ Team\n","date":"2023-04-14T00:00:00Z","image":"http://blog.yosyshq.com/static-2023/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20230414-released/","title":"Tabby CAD Suite version 20230414 released!"},{"content":"Welcome to the second part of the Colorlight 5A-75B article. You can find the first part here.\nIn this blogpost I will show you how to set up, synthesize and program your first Verilog program on the ECP5 FPGA using the Yosys suite.\n# The FPGA toolchain The FPGA workflow consists of a few more steps compared to the usual software toolchain workflow.\nThe Verilog source, which is a description of the logic that makes up the FPGA design, first needs to be synthesized. The synthesis process scans through all the source files and libraries to find out the hierarchy of the modules, starting with the specified top module. The result of this process is a low level logical representation of all the abstract components that will make up the final design. In the FPGA flow, this step is done by the yosys program, and results in a JSON file.\nThe next step in the toolchain is place-and-route. This is where the process becomes specific to the target FPGA family, because it takes the abstract components and maps it to physical parts that make up the FPGA. The logical design is translated into configuration data for all the switches, lookup tables and registers in the FPGA\u0026rsquo;s macroblocks. Yosys suite includes the Nextpnr tool which does this step. For our board, which runs on the Lattice ECP5 fpga, we will have to use the nextpnr-ecp5 program. This will give us a .config file which represents the configuration of the fpga.\nThe last step is to upload the configuration data to the target FPGA. This step can have many forms, but in Yosys it has two parts: packing and uploading. First, the configuration data needs to be packed into a format that is recognized by the FPGA controller. This is done with the ecppack executable. We will use ecppack to create an SVF (Serial Vector Format). The SVF is a pretty ingenious hack - the file contains plain JTAG commands that need to be sent to the target, which makes it independent from the JTAG adapter. Using SVF, in principle, you can program any JTAG device with any JTAG adapter. The second part is the actual upload of the SVF to the device. We will use openocd to communicate with our JTAG adapter and upload the SVF file with configuration data to it. After the upload is complete, the FPGA will start running.\n# Hello, blink! For our journey into getting the board to blink, we will use the following Verilog. It\u0026rsquo;s a simple clock divisor module whose output is connected to an IO pin on the FPGA that is connected to the onboard LED.\nmodule top(input clk_i, output led_o); reg led_reg; wire baseclk; clkdiv #(.DIV(2000000)) slowclk (clk_i, baseclk); always @(posedge baseclk) begin; led_reg \u0026lt;= !led_reg; end assign led_o = led_reg; endmodule module clkdiv #(parameter DIV = 24'd5000)( input wire clk_i, output wire clk_o ); reg [24:0] count = 25'b0; reg clk_o_internal = 1; //on this board we have a 25MHz clock always @(posedge clk_i) begin count \u0026lt;= count + 25'b1; if(count == DIV) begin count \u0026lt;= 25'b0; clk_o_internal \u0026lt;= ~clk_o_internal; end end assign clk_o = clk_o_internal; endmodule This piece of Verilog will take the clock input from the onboard oscillator, divide it by 500 thousand and output the divided clock to output led_o.\nI\u0026rsquo;ve called the file blink.v. Now we need to synthesize it using yosys:\nyosys -p \u0026quot;synth_ecp5 -top top -json blink.json\u0026quot; blink.v It is important to specify the top module by name using the -top \u0026lt;name\u0026gt; option. Otherwise yosys may pick the wrong module as the top and later cause an error due to unconstrained IOs.\nThe next step is to assign the logic IOs from the verilog modules to physical pins on the FPGA. This is necesary for the Place and Route step and is done by a constraints file. Looking up q3k\u0026rsquo;s repository on the 5A-75B board we can find out that the clock is connected to FPGA pin P6, and the onboard led is connected to T6. Here is how the LPF file looks like. I saved it as blink.lpf:\nLOCATE COMP \u0026quot;clk_i\u0026quot; SITE \u0026quot;P6\u0026quot;; IOBUF PORT \u0026quot;clk_i\u0026quot; IO_TYPE=LVCMOS33; LOCATE COMP \u0026quot;led_o\u0026quot; SITE \u0026quot;T6\u0026quot;; IOBUF PORT \u0026quot;led_o\u0026quot; IO_TYPE=LVCMOS25; Now we can run the Place and Route program, nextpnr-ecp5:\nnextpnr-ecp5 --json blink.json --textcfg blink_out.config --25k --package CABGA256 --lpf blink.lpf We specify the parameters of the ECP5 FPGA: device type LFE5U-25F (--25k) and the package type.\nWith the output config file all we need to do is to pack the bitstream into an SVF file:\necppack --svf blink.svf blink_out.config blink.bit With the SVF file it\u0026rsquo;s time to program the bitstream into the FPGA. Connect it to your JTAG adapter and power.\nopenocd -f colorlight_5a75b.cfg -c \u0026quot;svf -quiet -progress blink.svf; exit\u0026quot; The file colorlight_5a75b.cfg contains my openocd configuration:\nsource [find interface/jlink.cfg] adapter_khz 500 transport select jtag jtag newtap ecp5 tap -irlen 8 -expected-id 0x41111043 init scan_chain targets svf -tap ecp5.tap -quiet -progress blink.svf exit the jtag newtap ... line defines a new Test Access Port that corresponds to the FPGA\u0026rsquo;s TAP. The first line configures openocd to use a JLink as the adapter. If you have a different adapter, then modify this file to your needs.\nThe example project, along with a Makefile is available on GitHub\n# About the author Chris \u0026ldquo;polprog\u0026rdquo; Lasocki (@polprogpl) is a long time electronics hacker and an aspiring physicist. FPGAs are one of his hobbies and he is currently writing a thesis in that field. His other interests include laser physics as well as embedded programming projects. He runs a blog at polprog.net.\n","date":"2023-03-28T18:17:00+02:00","image":"http://blog.yosyshq.com/static-2022/colorlight_5a75b.jpg","permalink":"http://blog.yosyshq.com/p/colorlight-part-2/","title":"First gateware on the Colorlight 5A-75B board "},{"content":"Tabby CAD Suite version 20230306 released!\nThe March release of Tabby CAD Suite is now available for download. Notable changes in this version include:\nThere is now support for tying licenses to Google Cloud Instance ID and to GitLab groups or repositories. In other YosysHQ news:\nWe have a new community spotlight article about sv2v. sv2v converts SystemVerilog (IEEE 1800-2017) to Verilog (IEEE 1364-2005), with an emphasis on supporting synthesizable language constructs. Our GitHub action that installs the oss-cad-suite has had an update. Happy March, The YosysHQ Team\n","date":"2023-03-06T00:00:00Z","image":"http://blog.yosyshq.com/static-2023/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20230306-released/","title":"Tabby CAD Suite version 20230306 released!"},{"content":"The OSS CAD suite setup GitHub action just had an update, fixing an issue where sometimes the install would fail due to rate limiting.\nThe OSS CAD suite makes it simple to install a whole set of tools at once, and the GitHub action makes it just as simple to get the tools available for a CI job.\nTools are included for:\nSynthesis Formal verification FPGA place and route FPGA board programming Simulation and testing ","date":"2023-02-20T11:48:40+01:00","image":"http://blog.yosyshq.com/static-2023/githubaction.png","permalink":"http://blog.yosyshq.com/p/oss-cad-suite-github-action-update/","title":"OSS CAD Suite Github Action Update"},{"content":" # sv2v Welcome to another community spotlight article where we shine a light on open source EDA projects. If you want to submit a project, please do so here.\nsv2v converts SystemVerilog (IEEE 1800-2017) to Verilog (IEEE 1364-2005), with an emphasis on supporting synthesizable language constructs.\n# Zachary Snow\u0026rsquo;s Bio I received my B.S. in computer science from Carnegie Mellon University in 2019. After graduating, I began working full-time as a software engineer in systematic trading. Since May, I have worked in systematic futures trading at the D. E. Shaw group.\n# What was your motivation in making sv2v? While working as an undergraduate teaching assistant, Professor Dave Eckhardt introduced me to an open hardware research group that includes himself and Professor Ken Mai. Leveraging my prior studies in compilers, I was tasked with developing a tool to convert a RISC-V core written in SystemVerilog to Yosys-compatible Verilog. With help from others on the research team, we accomplished this goal prior to my graduation. Since then, I have continued to develop sv2v on a volunteer basis with the support of CMU and the larger open hardware community.\n# Why do you develop open source tools? While I enjoy programming projects in general, I find working on open source tools especially rewarding. I appreciate that each improvement can benefit many users. I hope that my contributions can expand the viability of completely free and open source development in a space that is dominated by proprietary tools.\n# What are some of the challenges you face? I have no formal training in electrical engineering or hardware development. Although I have gained experience since starting the project, I still depend on insight and advice from those who actually work on hardware and synthesis flows.\nSystemVerilog is also a difficult language to work with due to its complexities and ambiguities. Even commercial toolchains vary in terms of feature support, strictness, and behavior. This can make it challenging to decide what language features to implement and how to translate them correctly.\n# What could the community do to support you? I am always eager to receive more feedback. It is difficult to gauge interest in features or discover issues without users sharing their thoughts. The feedback I‚Äôve received to date has been essential in making sv2v what it is today.\nFor those with experience with functional programming or compilers and an interest in SystemVerilog, there are a number of features and improvements that may be suitable for an outside collaborator. If you‚Äôre interested, please reach out!\n# What is the best link for the project? https://github.com/zachjs/sv2v\n# What is the best way for people to contact you? GitHub: https://github.com/zachjs Website: https://zachjs.com ","date":"2023-02-13T13:26:31+01:00","image":"http://blog.yosyshq.com/static-2022/spotlight/spotlight.png","permalink":"http://blog.yosyshq.com/p/community-spotlight-sv2v/","title":"Community Spotlight - sv2v"},{"content":"Tabby CAD Suite version 20230208 released!\nThe February release of Tabby CAD Suite is now available for download. Notable changes in this version include:\nSBY can now use Yosys‚Äôs builtin simulation command ‚Äúsim‚Äù to generate counter-example traces. This can be enabled with the ‚Äúvcd_sim on‚Äù option and will become the default in a later release. Using Yosys‚Äôs ‚Äúsim‚Äù command, SBY now supports writing traces in gtkwave‚Äôs FST format in addition to the VCD format. FST files offer improved handling of signal names containing special characters, native compression and faster load times. This can be enabled with the ‚Äúfst on‚Äù option In other YosysHQ news:\nWe have a new guest blog post from Victor Suarez Rovere and Juilan Kemmerer about a fully open source ‚ÄúC to FPGA‚Äù toolchain. YosysHQ is working with Tillitis in the development of their next FPGA based product. Happy February, The YosysHQ Team\n","date":"2023-02-08T00:00:00Z","image":"http://blog.yosyshq.com/static-2023/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20230208-released/","title":"Tabby CAD Suite version 20230208 released!"},{"content":"We are happy to announce that we are working with Tillitis on their next generation of USB security key.\nTheir current model TKey‚Ñ¢ is open source hardware and software. It uses a Lattice iCE40, chosen due to it being supported by our open source FPGA tools.\nThe new version includes an upgraded FPGA with more security features. YosysHQ will be working to add support for this FPGA to NextPNR.\nThe best news is that the work will be open sourced so you will soon have a new family of FPGAs to experiment with!\nFollow Tillitis on Linkedin or Twitter.\n","date":"2023-02-06T11:56:24+01:00","image":"http://blog.yosyshq.com/static-2023/tillitis.jpg","permalink":"http://blog.yosyshq.com/p/tillitis-and-yosyshq/","title":"Tillitis and YosysHQ"},{"content":"This guest post is by Victor Suarez Rovere and Julian Kemmerer.\n# 3D raytraced game using fully open source ‚ÄúC to FPGA‚Äù toolchain Sphery vs. Shapes is the world\u0026rsquo;s first 3D raytraced game implemented completely as digital logic. This is all made possible by combining the OSS CAD Suite with CFlexHDL and PipelineC.\n# Summary In this article we present a tool flow that takes C++ code describing a raytraced game, and produces digital logic that can be implemented in off-the-shelf FPGAs (with no hard or soft CPU used). We aim for these tools to achieve a software friendly C-to-FPGA flow, making the development + simulation process exceptionally fast and easy, while providing high performance and low power hardware results.\nThanks to project Trellis, Yosys and nextpnr can complete an open source synthesis and place and route flow for ECP5 FPGAs. This was the final piece needed to complete our C-\u0026gt;Bitstream workflow based on fully open source tools.\nDemo video and full sources: https://github.com/JulianKemmerer/PipelineC-Graphics\n# FPGA as a raytracer Interactive ray tracing hardware is novel in FPGA and our work serves as a perfect example that such complex data processing circuits can be developed, tested, and implemented in hardware all from a C language based flow that greatly eases the design process over traditional hardware description languages.\nUltra-fast compiled C based emulation and C++ based tools like Verilator allow for fast simulation with realtime debug. This quick workflow is essential, being able to compile-as-C and see the results of code changes executed in realtime is a requirement for developing an interactive game, something not possible with standard FPGA simulators.\nThe project generates each video pixel in hard-realtime ‚Äúchasing the beam‚Äù, without a frame buffer and with zero jitter. Medium size Xilinx Artix 7 FPGAs have reached up to 1080p 60FPS (148.5MHz pixel clock). This article describes using an Lattice ECP5 FPGA to reach 480p 60FPS (25MHz pixel clock). Pipelining the entire ray tracer produces a position-to-color latency of a few microseconds at most. 1080p requires about ~400 pipeline stages, 480p requires ~70 stages - in both cases this pipelining is done automatically as part of the tool flow.\nThe Xilinx Artix 7 FPGA achieves about 70 GFLOP/s using less than 1 watt, thanks to the pipeline with dozens of hardware resources working in parallel. Using that 28nm Xilinx 7 series FPGA, power reduction was calculated to be about 50X less compared with a modern 7nm CPU running heavily vector optimized instructions.\n# Workflow The workflow allows writing algorithms involving complex types like structures, floating point types and operations on vectors of those, all keeping a clean and familiar syntax.\nThe source code is first converted by the CflexHDL tool from C++ to C. Then this subset of C can be converted to VHDL by PipelineC . GHDL and Yosys are used to convert the output VHDL into netlists that nextpnr can use.\nIn addition to simple conversion to VHDL, PipelineC is primarily the mechanism for producing pipelined digital logic from the pure combinatorial logic derived from C code. PipelineC is aware of the FPGA timing characteristics of the specific device (by iterating with nextpnr) and adds pipelining as needed to meet timing. This avoids the tedious and error-prone task of manual pipelining that digital designers are familiar with. The flow reports a preliminary estimate of resources prior to synthesis and the amount of pipeline stages required to implement the user‚Äôs functionality.\nTo produce a final bitstream GHDL+Yosys are used to generate a flattened single Verilog file version of the design that can easily be incorporated into existing build flows for board specific bitstream support, ex. Litex Orange Crab.\nAlternatively, the sources can be compiled and run ‚Äúas C‚Äù, as a kind of ultra-fast emulation/simulation (the game can be played in FullHD at 60FPS during debug on PC), or the Verilog sources can be processed by Verilator and graphically simulated by another tool we provided.\nFrom inside the PipelineC-Graphics repository there is one command to go from C file to the final bitstream generation and load your FPGA board: make load. See additional instructions on github.\n# Hardware architecture The project uses a fully open source board based on a Lattice ECP5 FPGA with 85K LUTs (the OrangeCrab board) plus a PMOD-compatible digital video connector for direct connection to a monitor by adapting 3.3V signals to the required CML levels (Machdyne DDMI), they publish schematics as well. For simplicity, only the positive polarity and ground were connected: it works since the differential levels are met, at least on our test setup. The integrated button on the FPGA board is used to play the game.\nThis setup allowed 640x480 resolution (25MHz clock) instead of 1920x1080 (148.5MHz clock) as achieved with the original setup using a Xilinx 7 series FPGA device.\nThe FPGA design consists of two main blocks: a state machine computing frame-by-frame animation and a long pixel rendering pipeline.\nTo meet 25MHz timing on the Lattice ECP5 FPGA the PipelineC tool created a pixel rendering pipeline of approximately ~70 stages. Below is a visual breakdown of how many stages each major function takes and roughly where/when in the pipeline it occurs:\nThe above pipeline uses operations on custom floating and fixed point types.\nOperation Stages Fixed Compare 1 stage Fixed Addition/Subtraction 2 stages Fixed Multiplication 2 stages Float Compare 2 stages Float Multiplication 2 stages Float Addition/Subtraction 3 stages Float Fast Reciprocal 3 stages Float Fast Reciprocal Square Root 3 stages Float Fast Square Root 3 stages Float Fast Division 4 stages Float 3D Vector Dot Product 5 stages Float 3D Vector Normalize 7 stages Ray Plane Intersection 10 stages Ray Sphere Intersection 22 stages Float types use a 14 bit mantissa instead of the typical 23 bits, and fixed point values are represented with a total of 22 bits: 12 for integer portion, 10 for the fractional bits. Those types are provided by CflexHDL types and the effects of reduced precision can be readily appreciated with the provided graphical simulation tool, so the optimal size is easy to determine by performing the fast simulations.\nFull precision vs. reduced precision in simulator window\nTypical times for development/test cycles are as follows:\nBuild command Build time Speed @1080p Fast CPU simulation make sim 1s 60-86 FPS Precise CPU simulation make gen 5s 40FPS Logic simulation make verilator 1min 50s 50s per frame # Software architecture and components All software and tools used in this project are Open Source. We integrated the following components:\nPipelineC for C to VHDL, autopipelining (uses pycparser) CflexHDL for C++ parsing, fixed point types and arbitrary width floating point types, and vector of these using operator overloading Clang‚Äôs cindex to help in parsing C++ Verilator for logic level simulation Custom simulator based on the SDL libraries (used when compiling the raytracer, or after Verilator C++ generation) YosysHQ\u0026rsquo;s Yosys for Verilog parsing and synthesis NextPNR for place and route (project Trellis) GHDL from a Yosys plugin for VHDL to Verilog conversion (used by Verilator and for synthesis) LiteX for Orange Crab SoC design, and its video core with serialized digital outputs (DVI) # About OSS CAD Suite Integration The first version of the project used a commercial FPGA board and closed-source synthesis tools. After Project Trellis reverse-engineered the ECP5 device there were only a few minor workarounds that were needed to complete the chain of ‚Äúeverything open source‚Äù with Yosys and nextpnr.\nPart of PipelineC‚Äôs autopipelining iterations involve synthesizing the design purely as combinatorial logic (pre-pipelining). The share pass that Yosys uses by default for synth_ecp5 does not handle the massive combinatorial network that defines the ray tracer design very well. RAM usage (typically ~8GB max) quickly jumps past the 16GB we had on our workstations. Disabling the share pass required editing the Yosys source code to remove the specific ECP5 run step.\nThe second issue we ran into was that in early versions of ECP5 place and route support, nextpnr was not able to pack LUTs+FFs into the shared primitive block as effectively as today. As such, early attempts failed to place and route the design while still having relatively plenty of resources remaining. But after the packing support improved, nextpnr began to produce fully placed and routed designs that could be further iterated on for pipelining. Related: often the nextpnr tool would end up in an infinite loop trying to fix a few remaining overused/unrouted wires - but recent changes seem to have reduced that issue as well.\nSince the PipelineC tool generates VHDL, we needed to convert the final generated sources to a single Verilog file (to be used in Verilator simulation and to generate the bitstream). This is done using the GHDL plugin for Yosys and the Yosys write_verilog command. Occasionally Yosys passes like opt and flatten were needed during the import process in order to avoid spikes in RAM usage.\nNone of these issues were blockers for long. We credit success to the fantastic open source community that provided lots of help in forums and discussions.\n# Conclusions We showed a ready-to-use toolchain for hardware design that greatly accelerates development time by using fast simulators at different stages, based on a known programming language syntax. The code can be translated to a logic circuit or run on a off-the-shelf CPU. A example application requiring complex processing was demonstrated by writing a game that implements the usual math operations for raytracing applications, with a clean syntax for math and all the algorithms. Since we apply an automatically calculated -and possibly long- pipeline, the system is capable of performing very well even compared to powerful modern CPUs, but using smaller and embeddable chips, at low power.\n# About the authors This work is a result of the tight interactions between Julian Kemmerer (@pipelinec_hdl; fosstodon.org/@pipelinec) and Victor Suarez Rovere (Twitter: @suarezvictor) during almost a year.\nVictor Suarez Rovere is the author of CflexHDL tool used in this project (parser/generator and math types library) and of the Sphery vs. Shapes game. He‚Äôs a software and hardware developer and consultant experienced in Digital Signal Processing, mainly in the medical Ô¨Åeld. Victor was awarded the Ô¨Årst prize in the Argentine National Technology contest, a gold medal from WIPO as \u0026ldquo;Best young inventor\u0026rdquo; and some patents related to a multitouch technology based on tomography techniques.\nJulian Kemmerer is the author of the PipelineC tool (C-like HDL w/ auto-pipelining) used in this work. He earned a Masters degree in Computer Engineering from Drexel University in Philadelphia where his work focused on EDA tooling. Julian currently works as an FPGA engineer at an AI focused SDR company called Deepwave Digital. He is a highly experienced digital logic designer looking to increase the usability of FPGAs by moving problems from hardware design into a familiar C language look.\n","date":"2023-02-03T12:00:00+02:00","image":"http://blog.yosyshq.com/static-2023/sphery.png","permalink":"http://blog.yosyshq.com/p/3d-raytracing/","title":"3D raytraced game with open source C to FPGA toolchain"},{"content":"Tabby CAD Suite version 20230104 released!\nThe January release of Tabby CAD Suite is now available for download. With the holidays there have been only a few changes, of note:\nSBY output is now in color. # In other YosysHQ news: We have reformatted our service table to clarify some points we\u0026rsquo;ve seen cause confusion. Don\u0026rsquo;t worry, our prices remain the same as they\u0026rsquo;ve always been! Our first community spotlight article is about Tbengy, which is a Python Tool for SV/UVM Testbench Generation and RTL Synthesis. Happy New Year! The YosysHQ Team\n","date":"2023-01-04T00:00:00Z","image":"http://blog.yosyshq.com/static-2023/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20230104-released/","title":"Tabby CAD Suite version 20230104 released!"},{"content":" # Tbengy Welcome to the first in a series of short articles where we shine the light on open source EDA projects. If you want to submit a project, please do so here.\nTbengy by Prasad Pandit is a Python Tool for SV/UVM Testbench Generation and RTL Synthesis. The tool uses newly available capability of the Vivado tool by Xilinx to compile and run SV/UVM Testbench and syntheize RTL for Digilent FPGA Boards.\nThe project is hosted on Github under an MIT License:\nhttps://github.com/prasadp4009/tbengy\n# Prasad Pandit\u0026rsquo;s Bio I am a Hardware Engineer by profession which is my hobby as well. I enjoy tinkering with FPGAs, Arduinos and building IoT devices to make my life more easy. My interest revolves around making chips and building things with 3D printers.\n# Motivation to make tbengy: I have been developing and using small python scripts for personal use. During the pandemic, as we all know many people lost their jobs including engineers from the Semiconductor Industry. In the same time period, I got a chance to tinker with my FPGAs and was working on developing a tool that can help me create a project skeleton as well as scripts to test my design and verify them. When it comes to design compilation, whether it\u0026rsquo;s VHDL, Verilog or Systemverilog we have a lot of open-source as well as commercial tools, problem comes when we want to compile UVM for verification. There isn\u0026rsquo;t much scope for people other than using EDAPlayground or use Commercial tools which are not easily available. Also maintaining projects on EDAPlayground in a structured way is not supported.\nWhile updating my Vivado, I read the release notes and found that the Webpack version (free version) now supports complete UVM 1.2 compilation and simulations. This gave me the idea to build a python tool \u0026ldquo;tbengy\u0026rdquo;, which can run on any OS (Windows or Linux) and generates an easily editable and compilable UVM testbench in a structured manner and scripts which will help engineers interested in UVM verification to hone their skills on their machine. I also added support for a Blinky project which generates design, DV and synthesis scripts for all Digilent boards.\n# Why open source? I believe in open collaboration. Linux is the best example of what open source can bring to this world and that inspired me to be a part of this community. The Open source tools like MAGIC and OpenROAD which today makes it possible for anyone to design ASICs right from their own machine, this is another motivation for me to give more to this community.\n# What are the challenges? Being a hardware engineer, software is not my expertise. This became more evident to me when I created string templates in python where after some research I figured there are template libraries like Jinja2, which if used will help a lot in bringing the knowledge of hardware with use of more structured and efficient software in making better tools.\n# What could the community do to support you? I found out that it\u0026rsquo;s difficult to get your work reviewed in open source and tapping the right audience. I will be glad if experienced users both from hardware and software domain can review the tool and provide better direction as well as requirements will help in taking the tool to the next level.\n# Connect with Prasad Pandit LinkedIn: https://www.linkedin.com/in/panditprasad/ YouTube: https://www.youtube.com/@PrasadPandit Twitter: https://twitter.com/@tonystark_hdl ","date":"2022-12-14T10:23:57+01:00","image":"http://blog.yosyshq.com/static-2022/spotlight/spotlight.png","permalink":"http://blog.yosyshq.com/p/community-spotlight-tbengy/","title":"Community Spotlight - Tbengy"},{"content":"The December release of Tabby CAD Suite is now available for download. Notable changes in this version include:\nWe have improved support for SystemVerilog config elements. You can now have multiple configurations defined, and select which configuration to elaborate with verific -import \u0026lt;configname\u0026gt;. We are working on improving the TCL integration in Yosys. There is now an interactive TCL shell mode: use yosys -C to enter the TCL shell. You can now also use the following command to get the output of a command returned to TCL without the use of an intermediate file: set command_output [yosys tee -s result.string \u0026lt;command\u0026gt;] # In other YosysHQ news We had another great guest blogpost from Tom Verbeure. He wrote about how Yosys does techmapping, in particular logic primitive transformations. If you‚Äôve not read any of Tom‚Äôs other writing, he has a very interesting index here. Two of our favourites are Post-Simulation Waveform-Based RISC-V with GDB and Cosimulating Verilog and VHDL with CXXRTL. We are starting a ‚Äòcommunity spotlight‚Äô feature to help highlight useful open source EDA tools. If you have a tip, please let us know. ","date":"2022-12-12T00:00:00Z","image":"http://blog.yosyshq.com/static-2022/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20221205-released/","title":"Tabby CAD Suite version 20221205 released!"},{"content":"This guest post is by Tom Verbeure.\n# Introduction If you\u0026rsquo;re reading this you probably already know that Yosys is an open source logic synthesis tool. You may also know that it\u0026rsquo;s much more than that: in my earlier blog post about CXXRTL I call it the swiss army knife of digital logic manipulation.\nIn most cases, using Yosys means running pre-made scripts that contain Yosys commands: when I\u0026rsquo;m synthesizing RTL for an FPGA of the Lattice iCE40 family, the synth_ice40 command is usually sufficient to convert my RTL into a netlist that can be sent straight to nextpnr for place, route, and bitstream creation.\nMy current version of Yosys has 232 commands, and many of these commands have an impressive list of additional options, but sometimes you want to perform very particular logic operations that don\u0026rsquo;t come standard with the tool.\nIn this blog post, I\u0026rsquo;ll talk about the techmap command, a particularly powerful command that allows one to make custom logic transformations by replacing a logic cell instance of a given type to one or more different ones.\n# Mapping a multiplication to an FPGA DSP Cell There is a companion yosys_techmap_blog project on GitHub that contains the Verilog source files and the scripts to generate the graphics and Yosys results of this blog post.\nA good example of a techmap operation is one where a generic multipication is converted into a DSP block of an FPGA. For those who are unfamiliar with the technology, FPGAs usually have only a few core logic primitives: lookup-table cells (LUTs) are used to construct any kind of random logic circuit, RAM cells are, well, RAMs, and DSPs are larger cells that contain one or more hardware multipliers, often in combination with an accumulator.\nLet\u0026rsquo;s look at this Verilog module, mul.v, that multiplies two 10-bit values into a 20-bit result:\nmodule top(input [9:0] op0, input [9:0] op1, output [19:0] result); assign result = op0 * op1; endmodule When reading in the Verilog file, Yosys translates it into RTLIL (RTL Internal Language), the internal representation of the design. The multiplication operation becomes a $mul primitive, and the whole design looks like this:\nmodule \\top wire width 10 input 1 \\op0 wire width 10 input 2 \\op1 wire width 20 output 3 \\result cell $mul $mul$mul.v:3$1 parameter \\A_SIGNED 0 parameter \\A_WIDTH 10 parameter \\B_SIGNED 0 parameter \\B_WIDTH 10 parameter \\Y_WIDTH 20 connect \\A \\op0 connect \\B \\op1 connect \\Y \\result end Yosys has the super useful show command that renders an RTLIL representation as a graph. I usually add the -width -signed options to annotate signals with their size and to show which cell ports are signed:\nThis primitive must be converted into cells of the target technology. Most FPGAs from the iCE40 family have a handful of DSPs. When you synthesize this module to the iCE40 technology with synth_ice40 -dsp, the $mul primitive gets converted to an SB_MAC16 cell which is the DSP primitive of the iCE40 family.\nThe SB_MAC16 DSP has a ton of data path and configuration signals, and the multiplier inputs and output can be up to 16 and 32-bits wide respectively. It\u0026rsquo;s up to a techmap step to assign all the right values to the configuration signals, and to correctly tie down unused input data bits or ignore excess output bits so that the DSP performs the desired 10-bit x 10-bit multiplication.\nAfter cleaning up some irrelevant cruft, the post-synthesis RTLIL looks like this:\nmodule \\top wire width 10 input 1 \\op0 wire width 10 input 2 \\op1 wire width 20 output 3 \\result wire \\result_SB_MAC16_O_ACCUMCO wire \\result_SB_MAC16_O_CO wire width 12 \\result_SB_MAC16_O_O wire \\result_SB_MAC16_O_SIGNEXTOUT cell \\SB_MAC16 \\result_SB_MAC16_O parameter \\A_REG 1\u0026#39;0 parameter \\A_SIGNED 0 parameter \\BOTADDSUB_CARRYSELECT 2\u0026#39;00 parameter \\BOTADDSUB_LOWERINPUT 2\u0026#39;10 parameter \\BOTADDSUB_UPPERINPUT 1\u0026#39;1 parameter \\BOTOUTPUT_SELECT 2\u0026#39;11 parameter \\BOT_8x8_MULT_REG 1\u0026#39;0 parameter \\B_REG 1\u0026#39;0 parameter \\B_SIGNED 0 parameter \\C_REG 1\u0026#39;0 parameter \\D_REG 1\u0026#39;0 parameter \\MODE_8x8 1\u0026#39;0 parameter \\NEG_TRIGGER 1\u0026#39;0 parameter \\PIPELINE_16x16_MULT_REG1 1\u0026#39;0 parameter \\PIPELINE_16x16_MULT_REG2 1\u0026#39;0 parameter \\TOPADDSUB_CARRYSELECT 2\u0026#39;11 parameter \\TOPADDSUB_LOWERINPUT 2\u0026#39;10 parameter \\TOPADDSUB_UPPERINPUT 1\u0026#39;1 parameter \\TOPOUTPUT_SELECT 2\u0026#39;11 parameter \\TOP_8x8_MULT_REG 1\u0026#39;0 connect \\A { 6\u0026#39;000000 \\op0 } connect \\ACCUMCI 1\u0026#39;x connect \\ACCUMCO \\result_SB_MAC16_O_ACCUMCO connect \\ADDSUBBOT 1\u0026#39;0 connect \\ADDSUBTOP 1\u0026#39;0 connect \\AHOLD 1\u0026#39;0 connect \\B { 6\u0026#39;000000 \\op1 } connect \\BHOLD 1\u0026#39;0 connect \\C 16\u0026#39;0000000000000000 connect \\CE 1\u0026#39;0 connect \\CHOLD 1\u0026#39;0 connect \\CI 1\u0026#39;x connect \\CLK 1\u0026#39;0 connect \\CO \\result_SB_MAC16_O_CO connect \\D 16\u0026#39;0000000000000000 connect \\DHOLD 1\u0026#39;0 connect \\IRSTBOT 1\u0026#39;0 connect \\IRSTTOP 1\u0026#39;0 connect \\O { \\result_SB_MAC16_O_O \\result } connect \\OHOLDBOT 1\u0026#39;0 connect \\OHOLDTOP 1\u0026#39;0 connect \\OLOADBOT 1\u0026#39;0 connect \\OLOADTOP 1\u0026#39;0 connect \\ORSTBOT 1\u0026#39;0 connect \\ORSTTOP 1\u0026#39;0 connect \\SIGNEXTIN 1\u0026#39;x connect \\SIGNEXTOUT \\result_SB_MAC16_O_SIGNEXTOUT end end And here\u0026rsquo;s the equivalent graphical representation. (Click to enlarge)\nAll Yosys commands are written in C++, but in the case of techmap the specific mapping operations are described in\u0026hellip; Verilog! It\u0026rsquo;s a very neat system that makes it possible for anyone to create their own custom mapping operations without the need to touch a line of C++.\nLet\u0026rsquo;s see exactly how that works for our example, and look at the source code of the synth_ice40 command.\nYosys places all the technology-specific operations under the techlibs directory. The code for synth_ice40 can be found in techlibs/ice40/synth_ice40.cc. synth_ice40 doesn\u0026rsquo;t really have any smarts by itself: it\u0026rsquo;s a macro command, a series of lower level Yosys commands strung together into a recipe.\nWhen you run help synth_ice40 in Yosys, you\u0026rsquo;ll see the following command line option:\n-dsp use iCE40 UltraPlus DSP cells for large arithmetic It\u0026rsquo;s easy to see which steps are activated in the source code when DSP mapping is enabled:\nrun(\u0026#34;memory_dff\u0026#34; + no_rw_check_opt); // ice40_dsp will merge registers, reserve memory port registers first run(\u0026#34;wreduce t:$mul\u0026#34;); run(\u0026#34;techmap -map +/mul2dsp.v -map +/ice40/dsp_map.v -D DSP_A_MAXWIDTH=16 -D DSP_B_MAXWIDTH=16 \u0026#34; \u0026#34;-D DSP_A_MINWIDTH=2 -D DSP_B_MINWIDTH=2 -D DSP_Y_MINWIDTH=11 \u0026#34; \u0026#34;-D DSP_NAME=$__MUL16X16\u0026#34;, \u0026#34;(if -dsp)\u0026#34;); run(\u0026#34;select a:mul2dsp\u0026#34;, \u0026#34; (if -dsp)\u0026#34;); run(\u0026#34;setattr -unset mul2dsp\u0026#34;, \u0026#34; (if -dsp)\u0026#34;); run(\u0026#34;opt_expr -fine\u0026#34;, \u0026#34; (if -dsp)\u0026#34;); run(\u0026#34;wreduce\u0026#34;, \u0026#34; (if -dsp)\u0026#34;); run(\u0026#34;select -clear\u0026#34;, \u0026#34; (if -dsp)\u0026#34;); run(\u0026#34;ice40_dsp\u0026#34;, \u0026#34; (if -dsp)\u0026#34;); run(\u0026#34;chtype -set $mul t:$__soft_mul\u0026#34;, \u0026#34;(if -dsp)\u0026#34;); There\u0026rsquo;s quite a bit going on here, but the most interesting command is this one:\ntechmap -map +/mul2dsp.v -map +/ice40/dsp_map.v -D DSP_A_MAXWIDTH=16 -D DSP_B_MAXWIDTH=16 -D DSP_A_MINWIDTH=2 -D DSP_B_MINWIDTH=2 -D DSP_Y_MINWIDTH=11 -D DSP_NAME=$__MUL16X16 What we see here is that techmap is performing the $mul to SB_MAC16 conversion in two steps:\nconvert $mul to a generic, technology independent DSP multiplier cell. convert the generic multiplier DSP cell to an iCE40 DSP cell. Step 1: mul2dsp.v\nStep 1 is done by mul2dsp.v. The code is a bit convoluted, but it has the answer as to why there\u0026rsquo;s this intermediate step:\nit deals with cases where a single $mul operation requires more than one DSP.\nFor example, a 32-bit x 32-bit to 64-bit multiplication is split into 4 16x16=32 multiplications and some additions.\nit doesn\u0026rsquo;t do the conversion when the inputs of the multiplication are too small\nThis avoids wasting precious DSP resources on something that can be implemented with core logic.\nThe -D ... arguments of the techmap command specify Verilog defines that are passed to the techmap file. It\u0026rsquo;s used to parameterize the conversion process:\n-D DSP_A_MAXWIDTH=16 -D DSP_B_MAXWIDTH=16 informs mul2dsp that the maximum input size of the DSP is 16 bits. -D DSP_A_MINWIDTH=2 -D DSP_B_MINWIDTH=2 -D DSP_Y_MINWIDTH=11 provides the minimum requirements that must be satisfied to do the conversion. -D DSP_NAME=$__MUL16X16 provides the name of the generic multiplier cells that should be created. We can run that first step by ourselves and check the result:\nread_verilog mul.v clean -purge techmap -map +/mul2dsp.v -D DSP_A_MAXWIDTH=16 -D DSP_B_MAXWIDTH=16 -D DSP_A_MINWIDTH=2 -D DSP_B_MINWIDTH=2 -D DSP_Y_MINWIDTH=11 -D DSP_NAME=$__MUL16X16 clean -purge show -width -signed -format png -prefix mul_mul2dsp In case you were wondering, here\u0026rsquo;s what this first step looks like for a 20-bit x 20-bit to 40-bit multiplier:\n(Click to enlarge)\nYosys can often create very long internal labels that stretch the graphical representation, so I zoomed the image to the part that counts. The 3 red rectangles are the $__MUL16X16 cells that will be converted to iCE40 DSPs. The blue rectangle is a $__soft_mul cell that will be converted into random logic at a large stage, and the 3 green rectangles are $add cells to bring the results of the different multipliers together.\nStep 2: ice40/dsp_map.v\nStep 2 of the techmap process, ice40/dsp_map.v is trivial: it converts the generic $__MUL16X16 multiplier cell into an SB_MAC16 cell, wires up the data path inputs and output, and straps all the other configuration inputs so that the cell is configured as a straight multiplier.\nmodule \\$__MUL16X16 (input [15:0] A, input [15:0] B, output [31:0] Y); parameter A_SIGNED = 0; parameter B_SIGNED = 0; parameter A_WIDTH = 0; parameter B_WIDTH = 0; parameter Y_WIDTH = 0; SB_MAC16 #( .NEG_TRIGGER(1\u0026#39;b0), .C_REG(1\u0026#39;b0), .A_REG(1\u0026#39;b0), .B_REG(1\u0026#39;b0), .D_REG(1\u0026#39;b0), .TOP_8x8_MULT_REG(1\u0026#39;b0), .BOT_8x8_MULT_REG(1\u0026#39;b0), .PIPELINE_16x16_MULT_REG1(1\u0026#39;b0), .PIPELINE_16x16_MULT_REG2(1\u0026#39;b0), .TOPOUTPUT_SELECT(2\u0026#39;b11), .TOPADDSUB_LOWERINPUT(2\u0026#39;b0), .TOPADDSUB_UPPERINPUT(1\u0026#39;b0), .TOPADDSUB_CARRYSELECT(2\u0026#39;b0), .BOTOUTPUT_SELECT(2\u0026#39;b11), .BOTADDSUB_LOWERINPUT(2\u0026#39;b0), .BOTADDSUB_UPPERINPUT(1\u0026#39;b0), .BOTADDSUB_CARRYSELECT(2\u0026#39;b0), .MODE_8x8(1\u0026#39;b0), .A_SIGNED(A_SIGNED), .B_SIGNED(B_SIGNED) ) _TECHMAP_REPLACE_ ( .A(A), .B(B), .O(Y), ); endmodule # A Horribly Contrived Example Problem Have a look at the following Verilog example code:\nmodule top_unsigned(input [5:0] op0, input [6:0] op1, output [63:0] sum); assign sum = op0 + op1; endmodule The graphical representation is as expected:\nI sometimes use CXXRTL to simulate my designs. When I run write_cxxrtl, the generated file contains the following:\nbool p_top__unsigned::eval() { bool converged = true; p_sum0 = add_uu\u0026lt;64\u0026gt;(p_op0, p_op1); return converged; } This is exactly as expected, and there\u0026rsquo;s nothing wrong with it. But one thing that bothers me is that CXXRTL uses 32-bit integer values (\u0026ldquo;chunks\u0026rdquo;) for all its operations. In the code above, there\u0026rsquo;s a 64-bit addition, and CXXRTL implements those by splitting things up into multiple 32-bit additions:\ntemplate\u0026lt;bool Invert, bool CarryIn\u0026gt; std::pair\u0026lt;value\u0026lt;Bits\u0026gt;, bool /*CarryOut*/\u0026gt; alu(const value\u0026lt;Bits\u0026gt; \u0026amp;other) const { value\u0026lt;Bits\u0026gt; result; bool carry = CarryIn; for (size_t n = 0; n \u0026lt; result.chunks; n++) { result.data[n] = data[n] + (Invert ? ~other.data[n] : other.data[n]) + carry; if (result.chunks - 1 == n) result.data[result.chunks - 1] \u0026amp;= result.msb_mask; carry = (result.data[n] \u0026lt; data[n]) || (result.data[n] == data[n] \u0026amp;\u0026amp; carry); } return {result, carry}; } It\u0026rsquo;s a hand-crafted carry-ripple adder. Now, don\u0026rsquo;t worry, things are really not as bad as it seems, because all the variables that are used for the if conditionals and the for loop are constants. Any good C++ compiler will optimize the addition above into only a few assembler instructions.\nIf you know your binary adder basics, you see that the addition of a 7-bit and a 6 bit operand will result at most in an 8-bit result. All higher bits will always be 0. It\u0026rsquo;s overkill to have a 64-bit adder.\nYosys already has the wreduce command that reduces logic operations to just the number of bits that are really needed.\nWe can see this when we run the following commands:\nread_verilog add.v hierarchy -top top_unsigned wreduce clean -purge And here\u0026rsquo;s the relevant CXXRTL generated code:\nbool p_top__unsigned::eval() { bool converged = true; p_sum0.slice\u0026lt;7,0\u0026gt;() = add_uu\u0026lt;8\u0026gt;(p_op0, p_op1); p_sum0.slice\u0026lt;63,8\u0026gt;() = value\u0026lt;56\u0026gt;{0u,0u}; return converged; } That looks better, but is that really true? The addition returns an 8-bit value, but since the smallest chunk is 32-bits, the slice\u0026lt;7,0\u0026gt; command now requires a read-modify-write operation.\nWhat I really want is this:\nbool p_top__unsigned::eval() { bool converged = true; p_sum0.slice\u0026lt;31,0\u0026gt;() = add_uu\u0026lt;32\u0026gt;(p_op0, p_op1); \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; 32 bits p_sum0.slice\u0026lt;63,32\u0026gt;() = value\u0026lt;32\u0026gt;{0u,0u};\t\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; 32 bits return converged; } Unfortunately, Yosys doesn\u0026rsquo;t have a command that does this for me, and I really don\u0026rsquo;t want to modify the C++ code of the wreduce command to make it so.\n# A Custom Techmap Transformation to the Rescue! If you start Yosys, running help techmap will give you an exhaustive list of all the features that you might ever need. But instead of repeating everything in there, let\u0026rsquo;s create an add_reduce techmap transformation to solve the problem of the previous section.\nHere are some of the basics of a techmap transformation Verilog module:\na techmap transformation only operates on a single design cell.\nYou can not use techmap to perform multi-cell optimizations such mapping a $mul followed by an $add onto an FPGA DSP has multiply-accumulator support.\na design cell that is transformed by a techmap is selected by a string that contains a list of cell types that are specified with the (* techmap_celltype \u0026quot;...\u0026quot;) attribute. If the techmap module doesn\u0026rsquo;t have such an attribute, then it\u0026rsquo;s determined by the name of the Verilog module.\nby default, a techmap operation will iterate on itself until there\u0026rsquo;s nothing left that matches.\nIf a techmap operation replaces an $add primitive by a new $add primitive, techmap will run again on the second one. Without some kind of abort mechanism, this will result in an endless loop!\nThere are multiple ways to avoid such an endless loop though. I\u0026rsquo;ll get to that later.\nit\u0026rsquo;s always a good idea to normalize the configuration on which you want to do the main transformation.\nHere\u0026rsquo;s a good example of what I mean by that: we want to reduce the size of an adder based on the size of its inputs. But an adder has 2 inputs, and if these inputs have a different size, then the transformation will have a different code path depending on which input is largest.\nHowever, an addition is commutative: the order of the inputs doesn\u0026rsquo;t matter.\nIt\u0026rsquo;s easier first do a normalization where the A input is guaranteed to be larger or equal than the B input by swapping the inputs, so that actual reduction transformation only has to deal with one case.\nThe earlier discussed mul2dsp techmap module does the same thing.\nThe add_reduce techmap module declaration\nIn this example, I want a transformation that only works on an $add instance, so I could create a techmap Verilog module like this:\nmodule \\$add(A, B, Y); ... But I prefer to use a descriptive name for the module and use the (* techmap_celltype ...) option to select the cell types on which the module operates:\n(* techmap_celltype \u0026#34;$add\u0026#34; *) module add_reduce(A, B, Y); ... The add_reduce techmap module interface\nThe techmap module interface should be the same as the cell on which it operates. Both the input/output signals and the parameters must be the same. Yosys has a Verilog file called simlib.v that contains the reference simulation modules of all its internal primitives. You can use this to check out the interface details of particular primitive.\nHere\u0026rsquo;s the one for the $add primitive\nmodule \\$add (A, B, Y); parameter A_SIGNED = 0; parameter B_SIGNED = 0; parameter A_WIDTH = 0; parameter B_WIDTH = 0; parameter Y_WIDTH = 0; input [A_WIDTH-1:0] A; input [B_WIDTH-1:0] B; output [Y_WIDTH-1:0] Y; The add_reduce techmap module has the same interface:\n(* techmap_celltype = \u0026#34;$add\u0026#34; *) module add_reduce (A, B, Y); parameter A_SIGNED = 0; parameter B_SIGNED = 0; parameter A_WIDTH = 1; parameter B_WIDTH = 1; parameter Y_WIDTH = 1; (* force_downto *) input [A_WIDTH-1:0] A; (* force_downto *) input [B_WIDTH-1:0] B; (* force_downto *) output [Y_WIDTH-1:0] Y; The force_downto attribute ensures that the highest numbered bit of each signal is the MSB. When this attribute is present, Yosys will automatically swap around the bits of connected wires so that you don\u0026rsquo;t need to worry about wackos who use bit 0 as MSB.\nadd_reduce stop conditions\nSince we\u0026rsquo;re replacing an $add primitive with another $add primitive, we need to make sure that there are special conditions to prevent the techmap operation to run forever.\nWe can tell the techmap command to stop transforming the current cell instance by assigning a non-zero value to the _TECHMAP_FAIL_ wire:\nwire _TECHMAP_FAIL_ = 1; For this operation, we want stop transforming an $add primitive for a number of conditions:\nwhen the size of the adder is already equal or smaller than the minimal desired adder.\nWe can set the minimum size with the `Y_MIN_WIDTH define.\nWhen the size of the adder can\u0026rsquo;t be reduced because it would change the result of the calculation.\nWhen it\u0026rsquo;s a signed addition and we only want to transform unsigned additions.\nThe `REDUCE_SIGNED define must be set to allow signed adder transformation.\nThis translates into the following code:\nlocalparam SIGNED_ADDER = (A_SIGNED == 1 \u0026amp;\u0026amp; B_SIGNED == 1); generate if (Y_WIDTH \u0026lt;= `Y_MIN_WIDTH) begin wire _TECHMAP_FAIL_ = 1; end else if (Y_WIDTH \u0026lt;= A_WIDTH+1) begin wire _TECHMAP_FAIL_ = 1; end else if (SIGNED_ADDER \u0026amp;\u0026amp; !`REDUCE_SIGNED) begin wire _TECHMAP_FAIL_ = 1; end ... There are other ways to prevent techmap to run forever. For example, in the mul2dsp.v code, a $__soft_mul cell used instead of a $mul primitive. Yosys has no such primitive, but in a later step, after techmap has been completed, this $__soft_mul cell is converted back to a $mul$ cell:\nchtype -set $mul t:$__soft_mul add_reduce normalization\nThe normalization code of add_reduce is pretty much a straight copy of the one from mul2dsp:\ngenerate ... else if (B_WIDTH \u0026gt; A_WIDTH) begin \\$add #( .A_SIGNED(B_SIGNED), \u0026lt;\u0026lt;\u0026lt; A and B are swapped .B_SIGNED(A_SIGNED), \u0026lt;\u0026lt;\u0026lt; .A_WIDTH(B_WIDTH), \u0026lt;\u0026lt;\u0026lt; .B_WIDTH(A_WIDTH), \u0026lt;\u0026lt;\u0026lt; .Y_WIDTH(Y_WIDTH) ) _TECHMAP_REPLACE_ ( .A(B), \u0026lt;\u0026lt;\u0026lt; .B(A), \u0026lt;\u0026lt;\u0026lt; .Y(Y) ); end else if ... When using _TECHMAP_REPLACE_ as instance name of the swapped $add primitive, it will inherit the instance name of the original instance. This is one of the many predefined variables that are explained by running help techmap in Yosys.\nSince we replace $add with $add, running techmap will result in the $add cell being transformed twice times if B is larger than A: the first time to swap the inputs, and the second time for the actual reduction.\nIf techmap needs to transform the same cell multiple times, it can be hard to debug. You can use the -max_iter \u0026lt;number\u0026gt; option to limit the number of transformations.\nFor example, here\u0026rsquo;s what the design originally looked like:\nAnd here\u0026rsquo;s how things look when stopping the add_reduce operation after the first iteration:\ntechmap -map add_reduce.v -max_iter 1 clean -purge op1 with the largest input size of 7 is now connected to A!\nThe actual add_reduce transformation\nNow that all preliminary formalities are behind use, the actual reduction code is pretty straightfoward:\nelse begin localparam ADDER_WIDTH = `MAX(`Y_MIN_WIDTH, A_WIDTH+1); \\$add #( .A_SIGNED(A_SIGNED), .B_SIGNED(B_SIGNED), .A_WIDTH(A_WIDTH), .B_WIDTH(B_WIDTH), .Y_WIDTH(ADDER_WIDTH) ) _TECHMAP_REPLACE_ ( .A(A), .B(B), .Y(Y[ADDER_WIDTH-1:0]) // Reduced output size ); // Higher bits are 0 or sign extension assign Y[Y_WIDTH-1:ADDER_WIDTH] = { (Y_WIDTH-ADDER_WIDTH){SIGNED_ADDER ? Y[ADDER_WIDTH-1] : 1\u0026#39;b0} }; end The final add_reduce.v code can be found here. We can run the whole thing with:\ntechmap -map add_reduce.v -D Y_MIN_WIDTH=32 clean -purge The result is exactly what we wanted, as shown in the graphical diagram\u0026hellip;\n\u0026hellip;and in the CXXRTL-generated code:\nbool p_top__unsigned::eval() { bool converged = true; p_sum0.slice\u0026lt;31,0\u0026gt;() = add_uu\u0026lt;32\u0026gt;(p_op1, p_op0); p_sum0.slice\u0026lt;63,32\u0026gt;() = value\u0026lt;32\u0026gt;{0u}; return converged; } # Formal Equivalence Check Whenever you do logic transformations, it\u0026rsquo;s not a bad idea to check that the pre- and post-transformation logic behaves exactly the same. Yosys has a basic built-in equivalence checker. It\u0026rsquo;s not a performance monster, but it\u0026rsquo;s good enough for this kind of use case.\nIn the example below, I\u0026rsquo;m verifying the add_reduce techmap on a design with an adder that has an output that\u0026rsquo;s 10 instead of 64 bits, and the minimum size is set to 8. This makes the size of the graphs more managable.\n# Load the original design read_verilog add.v hierarchy -top top_unsigned10 rename top_unsigned10 top_unsigned # Make a golden reference copy of the unmodified design copy top_unsigned top_unsigned_gold # Select the original version to do the techmap select top_unsigned # Do the techmap on top_unsigned techmap -map add_reduce.v -D Y_MIN_WIDTH=8 clean -purge So far, so good: Yosys now has 2 designs. top_unsigned_gold is the original one:\nAnd top_unsigned has been transformed with the techmap:\nLet\u0026rsquo;s compare them:\nequiv_make top_unsigned_gold top_unsigned top_equiv select top_equiv The equiv_make has the golden and the transformed design as input and creates a new design with $equiv primitive cells inserted at the output of both designs. These cells will tell the equivalence checker which nets to check for formal equivalence. The new design top_equiv looks like this:\n(Click to enlarge)\nAs you can see, the new design has both the golden and the transformed logic on the left, driven by the same inputs. For there are 10 $equiv cells, one for each bit of the output.\nWe can now run the equivalence check:\nequiv_simple You\u0026rsquo;ll see something like this:\n8. Executing EQUIV_SIMPLE pass. Found 10 unproven $equiv cells (1 groups) in top_equiv: Grouping SAT models for \\sum0: Trying to prove $equiv for \\sum0 [0]: success! Trying to prove $equiv for \\sum0 [1]: success! Trying to prove $equiv for \\sum0 [2]: success! Trying to prove $equiv for \\sum0 [3]: success! Trying to prove $equiv for \\sum0 [4]: success! Trying to prove $equiv for \\sum0 [5]: success! Trying to prove $equiv for \\sum0 [6]: success! Trying to prove $equiv for \\sum0 [7]: success! Trying to prove $equiv for \\sum0 [8]: success! Trying to prove $equiv for \\sum0 [9]: success! Proved 10 previously unproven $equiv cells. Each individual bit has been proven to be correct.\nWe can make Yosys fail if there were any unproven $equiv cells, like this:\nequiv_status -assert However, in our case, all is well:\n9. Executing EQUIV_STATUS pass. Found 10 $equiv cells in top_equiv: Of those cells 10 are proven and 0 are unproven. Equivalence successfully proven! We\u0026rsquo;ve now proven that our add_reduce techmap is correct, but that doesn\u0026rsquo;t mean it\u0026rsquo;s guaranteed bug free: we\u0026rsquo;ve only tested one combination of input and output signal sizes. To be absolutely sure, you\u0026rsquo;d need more variety of test cases.\nThis is only a quick example of what Yosys can do, there\u0026rsquo;s a variety of additional equivalence and logic proof features, most of which I don\u0026rsquo;t know much about! You could start by checking out the help information for the equiv_*, miter, and sat commands to learn more.\n# Cleaning Up When Yosys creates new cells and reconnects wires, it won\u0026rsquo;t immediately delete older cells and wires that aren\u0026rsquo;t used anymore. You need to expliclity tell Yosys to do so with the clean -purge command that you can see in some of the command sequences above.\nHere\u0026rsquo;s what the reduced adder looks like without first running a clean:\nThat\u0026rsquo;s why you see a clean -purge statement all over the place in the script generates all the pretty pictures of this blog post.\n# Conclusion Techmap is a very nice tool to have to transform single cells into something that better maps to your chosen target. The example that I\u0026rsquo;ve given here is a bit dumb (I\u0026rsquo;m not even sure if it would actually result in better compiled CXXRTL code!), but it shows some of the potential of what can be achieved.\nI have only scratched the surface of what can be done with it: there are ways to make a techmap module behave differently based on whether or not certain input bits are constant, you can instruct Yosys to run another Yosys command after performing a techmap iteration, and so forth.\nIf you want to go deeper, you should definitely start by checking out the help instructions, not only of techmap command, but also some of the other ones.\n# References Main Yosys repo on GitHub\nyosys_techmap_blog repo on GitHub\nContains the Verilog code and the Yosys scripts to generate all the graphs of this blog post.\n","date":"2022-11-24T09:38:52+02:00","image":"http://blog.yosyshq.com/static-2022/yosys_techmap/SB_MAC16_block_diagram.png","permalink":"http://blog.yosyshq.com/p/logic-primitive-transformations-with-yosys-techmap/","title":"Logic Primitive Transformations with Yosys Techmap"},{"content":"The November release of Tabby CAD Suite is now available for download. Notable changes in this version include:\nWe have experimentally added support for EDIF and Liberty verific parsers. They can be used either with the verific [-liberty|-edif] or the read [-liberty|-edif] command. We are evaluating whether it is of interest for us to keep these long-term, so please let us know if you use them and what your experience is!\n# In other YosysHQ news TinyTapeout is an educational project that makes it easier and cheaper than ever to get your digital designs manufactured on an ASIC. By leveraging open source tools like Yosys, the files required for manufacture are run in the cloud. Scroll to the bottom of the build results to see a cool interactive 3d viewer.\n","date":"2022-11-24T00:00:00Z","image":"http://blog.yosyshq.com/static-2022/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20221108-released/","title":"Tabby CAD Suite version 20221108 released!"},{"content":"The October release of Tabby CAD Suite is now available for download.\nThe read and verific commands now support here-documents in scripts, the same way as read_verilog. This is useful e.g. to have small self-contained tests in a single file such as:\nread -sv \u0026lt;\u0026lt;EOT module top(input clk, output reg [1:0] q); wire [1:0] x = 2'b10; always @(posedge clk) q \u0026lt;= x \u0026amp; 2'b11; endmodule EOT prep -top top sim -clock clk -n 1 -w top select -assert-count 1 a:init=2'b10 top/q %i ","date":"2022-10-17T00:00:00Z","image":"http://blog.yosyshq.com/static-2022/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20221011-released/","title":"Tabby CAD Suite version 20221011 released!"},{"content":"This guest post is the first in a two part series by Chris Lasocki. Part 2 is now available here.\nIt seems that it was an accident - a generic part of a LED display has become a low cost FPGA development board. The board in question is the Colorlight 5A-75B, which is a so-called receiver card. Featuring a Lattice ECP5 FPGA, supported by Yosys, it allows you to leverage a fully open-source FPGA development toolchain. Priced on average at 20-25 USD, it is a very accessible board.\nThe Colorlight 5A-75B was originally a part of a modular LED display standard. It\u0026rsquo;s a receiver card, which means that it sits between the computer controlling the show, and the LED panels themselves. It fulfills a basic but crucial task of receiving the video signal and driving the RGB panels accordingly. This takes a lot of bandwidth, so it is equipped with a moderately fast ECP5 LFE5U25-F FPGA and two Gigabit Ethernet interfaces. There is also a 16Mbit SDRAM for temporary storage and a Flash memory of the same size for storing the bitstream. It features 8 output ports of a known pinout (HUB75) and 5V outputs. The board has caught attention of hardware hackers and soon after was fully reverse engineered by q3k and others. A schematic with pinouts is available, as well as other documentation. A great amount of work has been done here and this is what enables the Colorlight board to be used in the hacker spirit way.\nAccidentally, this board design happens to be a great compromise between feature-rich and IO-rich. The only on-board peripherals are the basic or high speed ones, which would be hard to connect over the 0.1\u0026quot; pin headers. It is also the only development board with a dual Gigabit Ethernet interface in its price range. Since it\u0026rsquo;s just an FPGA, the 16MBit SDRAM should be enough for most applications, while being easy to implement a controller for.\n# Hacking the board With the on-board JTAG port, you just need to solder on a 4 pin header and you are ready to upload your own bitstreams to the ECP5 FPGA. This FPGA is fully supported by the Yosys toolchain, from the verilog compiler through place and route engine to the bitstream generator, and along with an open source JTAG adapter like the Bus Pirate (or anything else, really) it only takes a moment to send the bitstream down and see your code run. There is a great deal of user accessible IO broken out on the HUB75 headers.\nThe FPGA has a 25MHz clock directed to it, as well as one onboard LED and a button, which is plenty enough for a Verilog \u0026ldquo;Hello, world!\u0026rdquo; project - blinking the LED.\nThe only downside of this board is lack of inputs by default - You need to replace the 74HC245 output drivers with bidirectional level shifters. However there exists a pin compatible level shifter IC, SN74CBT3245A which can replace the default output driver providing 3v3 bidirectional IO. Other options, such as fabricating tiny PCBs that replace the shifters with wires, or connecting the direction pin of the output drivers to an IO pin are also a possibility.\n# Summary The Colorlight 5A-75B is a good choice for those who want to try open-source FPGA programming but do not wish to spend a significant amount of money for a classic development board. The on-board peripherals are enough for a first project to get acquainted with the toolchain. Gigabit Ethernet and SDRAM could also come in handy in future more advanced projects.\nIn the next post I will describe how to write, compile and upload a Verilog project that will blink the onboard led of the 5A-75B board.\n# About the author Chris \u0026ldquo;polprog\u0026rdquo; Lasocki (@polprogpl) is a long time electronics hacker and an aspiring physicist. FPGAs are one of his hobbies and he is currently writing a thesis in that field. His other interests include laser physics as well as embedded programming projects. He runs a blog at polprog.net.\n","date":"2022-10-16T18:17:00+02:00","image":"http://blog.yosyshq.com/static-2022/colorlight_5a75b.jpg","permalink":"http://blog.yosyshq.com/p/colorlight-part-1/","title":"Introducing the Colorlight 5A-75B board"},{"content":"The September release of Tabby CAD Suite is now available for download.\n# SBY SBY now runs multiple tasks in parallel. Additionally it now limits the number of concurrently running subprocesses to the available number of cores. The \u0026ndash;sequential command line option allows you to opt out of running tasks in parallel and the -j N option sets the limit of concurrent subprocesses to N instead of the default. All this is optionally integrated with the make jobserver protocol to enforce the concurrent process limit across other processes launched by make. There is a new SBY option vcd to enable or disable the generation of VCD traces. It defaults to on, but can be set to off when no traces are required to save runtime and disk space. VCD trace generation performance for the smtbmc engine is also improved in this release, so we recommend re-evaluating the performance before turning VCD trace generation off. # In other YosysHQ news We have recently overhauled the SBY getting started guide. Have a look if you need to onboard someone for SVA property checking! ","date":"2022-09-06T00:00:00Z","image":"http://blog.yosyshq.com/static-2022/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20220906-released/","title":"Tabby CAD Suite version 20220906 released!"},{"content":"The August release of Tabby CAD Suite is now available for download.\n# SBY SBY now uses a more precise logic loop analysis, removing the need to run simplemap on coarse-grain cells that re-use parts of a signal. # In other YosysHQ news Since we introduced the new autotune option, we‚Äôve now written up a blogpost with an example on how to get started. ","date":"2022-08-05T00:00:00Z","image":"http://blog.yosyshq.com/static-2022/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20220805-released/","title":"Tabby CAD Suite version 20220805 released!"},{"content":"Sby, our frontend for formal verification, makes it easy to use Yosys with the various open source verification tools that are included in our CAD suites. Sby integrates these tools as engines and provides a unified interface. Additionally, many of the verification tools internally use lower-level tools like SAT and SMT solvers and allow the user to select between different supported solvers.\nMost verification tasks can be performed by several of the supported engines and solvers. Depending on the specific verification task at hand, there can be large performance differences between them. Thus, it makes sense to try several engines and solvers to pick the best performing one.\nWith Sby, switching the engine or solver only requires changing a single line in the ‚Äú[engines]‚Äù section of the .sby file. Still, the large number of engine and solver configurations made it impractical to manually try all of them for every verification task, so it was easy to leave performance on the table by sticking with a worse performing configuration.\nTo help you get the best performance out of Sby, we now introduced the \u0026ndash;autotune option. If you add this option to your usual Sby invocation, it will go ahead and automatically try all recommended engine and solver combinations, producing a report that lists the best performing configurations. You can then copy a configuration from this report into your .sby file to use a faster engine for future sby invocations. From time to time, when updating the CAD suite, or making significant changes to your design, you can run autotune again to see if you are still using the best performing engine.\nSby \u0026ndash;autotune is also a lot smarter than just trying every configuration in sequence. It runs in parallel and knows how to use timeouts and retries so that a single slow engine that would take hours doesn‚Äôt keep Sby from quickly discovering a better configuration that finishes in seconds. When selecting the recommended engines and solvers, it also takes into account the design and settings in your .sby file to avoid known incompatibilities or performance issues.\nMore details on how to use and configure the automatic engine selection can be found in the corresponding section of the Sby documentation. If you want to try out the new autotune feature yourself, but don‚Äôt have a suitable Sby project at hand, you can try it on the small example project we prepared.\nAs always, we\u0026rsquo;re interested to hear how you get on with our tools\n","date":"2022-07-27T14:41:35+02:00","image":"http://blog.yosyshq.com/static-2022/autotune.png","permalink":"http://blog.yosyshq.com/p/sby-autotune/","title":"Autotune"},{"content":"The July release of Tabby CAD Suite is now available for download.\n# SBY An autotune function! This won‚Äôt fix your singing, but we hope it will help you to choose a good solver for your application. Please check the new documentation here to get started. Please let us know if you try the new feature. We will write a blogpost about it for the next newsletter. # In other YosysHQ news Since tribuf support was added in May, we wrote a short blogpost about Matt‚Äôs use of it for his latest ASIC submission. We also added an example to the sby examples. ","date":"2022-07-06T00:00:00Z","image":"http://blog.yosyshq.com/static-2022/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20220706-released/","title":"Tabby CAD Suite version 20220706 released!"},{"content":"Sby, our formal verification tool has recently got better support for tristate circuits. A tristate output is one that can either drive the connected wire to a high or low logic level or be in a high impedance state where it does not drive the output. This allows directly connecting multiple tristate outputs as long as no two are driving the output simultaneously. With tribuf (tristate buffer) support turned on, sby will automatically create assertions for any tristate signals that can be driven via multiples outputs. If more than one tristate output can drive the same wire, such an assertion will fail. For example:\nmodule module1 (input wire active, output wire tri_out); assign tri_out = active ? 1'b0 : 1'bz; endmodule module module2 (input wire active, output wire tri_out); assign tri_out = active ? 1'b0 : 1'bz; endmodule module top_fail (input wire clk, input wire active1, input wire active2, output wire out); module1 module1 (.active(active1), .tri_out(out)); module2 module2 (.active(active2), .tri_out(out)); endmodule And an .sby file with a script section that includes:\nprep -top top_fail flatten; tribuf -formal Will fail with a message like:\nAssert failed in top: tristates.v:3 ($tribuf_conflict$$flatten/module1.$verific$i6$tristates.v:3$9) By ensuring that only one tristate module is active at once, for example\nmodule top_pass (input wire clk, input wire active1, output wire out); module1 module1 (.active(active1), .tri_out(out)); module2 module2 (.active(!active1), .tri_out(out)); endmodule Sby will now finish with no errors. There is no need to add any assertion to the design, with the tribuf -formal command enabled in the [script] section of the sby file, the assertions are added automatically. Note that the flatten command is required when any module outputs can be tristate and that it has to precede the tribuf -formal command.\nYou can try the example out here: https://github.com/YosysHQ/sby/tree/master/docs/examples/tristate The sby file makes use of 2 different task sections.\nI recently used this feature to prove the safety of the tristate bus for an ASIC design. The ASIC combines 13 smaller projects with 45 verilog files. Sby completes a full proof with a depth of 5 clock cycles in 10 seconds. You can take a look at the project\u0026rsquo;s repository and the .sby file.\nThis shows that verifying meaningful properties of a larger design doesn\u0026rsquo;t have to take hours or even days. The time required to prove a property is not set by the overall design complexity. State of the art solvers are very good at cutting through a ton of logic to identify just the relevant parts. In solver terminology this is called an unsatisfiable core and on the hardware side this corresponds to a subcircuit that alone ensures that a property holds. That means you could change everything that is not part of this core circuit and the property would still hold. The complexity of this subcircuit is a much better indicator of the required solver effort.\nIf you are familiar with the cone of influence concept, where you find the relevant logic by following the circuit\u0026rsquo;s structure, this might sound familiar. An important difference is that solvers do not only consider the structure but also the behavior implemented by a circuit, which is more precise. Thus for the same property, an unsatisfiable core circuit can be much smaller than the cone of influence.\nFor selecting between different projects within a single ASIC design, most of the projects\u0026rsquo; logic is not part of the unsatisfiable core. Only the logic responsible for selecting which tristate outputs are active together with the automatically added conflict checks needs to be considered. This is great because for medium to large projects with many source files, the solver can still provide an answer very quickly.\nIf you have experience with proving simple properties in large designs please let us know - we‚Äôre always interested in how people are using our tools.\n","date":"2022-06-17T17:28:17+02:00","image":"http://blog.yosyshq.com/static-2022/tristate.png","permalink":"http://blog.yosyshq.com/p/formal-trisate-support/","title":"Formal Tristate Support"},{"content":"The June release of Tabby CAD Suite is now available for download.\n# Yosys A big overhaul of memory inference in Yosys. The new pass memory_libmap supports a wider variety of memory patterns, such as single-port memories or asymmetric memories. It will also strictly respect verilog semantics in cases of address collision, adding emulation circuitry to ensure the synthesized behavior matches simulation. To omit the emulation circuitry even in cases where it is required for correctness, you can add the (* no_rw_check *) attribute to the array declaration of the memory. To disable collision handling globally, calling memory with the -no-rw-check option is also possible (and the corresponding option has been added to all synth passes using the new memory_libmap pass).\n","date":"2022-06-10T00:00:00Z","image":"http://blog.yosyshq.com/static-2022/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20220610-released/","title":"Tabby CAD Suite version 20220610 released!"},{"content":"The May release of Tabby CAD Suite is now available for download.\n# SBY The tribuf pass now supports a -formal option that converts inferred tri-state buffers within a module into equivalent non-tri-state logic for formal verification. It automatically adds assertions that detect multiple drivers driving the same net simultaneously. (When using tri-state I/O across modules, tribuf -formal should be preceded by a flatten pass). Several changes in the handling of x values during formal verification. In particular, when using the Verific frontend, during the initial time step, value change expressions ($rose, $fell, $changed, $stable) are now always computed as if the argument changed from x to its initial value. This follows the SystemVerilog standard and ensures that any high (or low) signal starts at a step where $rose (or $fell) is true. # In other YosysHQ news Teodor-Dumitru Ene recently spoke about Open-Source Hardware Addition on SKY130. He has made a Yosys plugin that allows the designer to choose what algorithm to use. We are very happy to announce that Mullvad are sponsoring the development of the open source tools. Thanks Mullvad, and if you need a VPN, be sure to check them out! ","date":"2022-05-12T00:00:00Z","image":"http://blog.yosyshq.com/static-2022/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20220512-released/","title":"Tabby CAD Suite version 20220512 released!"},{"content":"Teodor-Dumitru Ene will be presenting his work on adder optimisations, he\u0026rsquo;ll be covering:\nPrefix sums His research Adder-specific quirks and optimizations Future goals Questions! Please join us:\nTuesday, 10 May ¬∑ 17:30 ‚Äì 18:30 CEST Streaming on youtube ","date":"2022-05-06T09:38:52+02:00","image":"http://blog.yosyshq.com/static-2022/adders.jpg","permalink":"http://blog.yosyshq.com/p/optimising-adders/","title":"Teodor-Dumitru and the Complexity of Adder Implementations in Hardware"},{"content":"The April release of Tabby CAD Suite is now available for download.\n# Yosys The sim command now allows co-simulation with stimulus values from aiger and btor2 witness files as well as traces in VCD or FST format. Co-simulation of designs with multiple clock domains was improved. # SBY The --keep-going option was added to the smtbmc engine. With this option, the solver will continue to check the remaining properties even after an assertion fails. To use it, add the option between the engine and the solver in the .sby file:\n[engines] smtbmc --keep-going boolector The JUnit report produced by sby will now list the status individually for each property when the engine supports it (currently only with smtbmc).\n# In other YosysHQ news We just welcomed 3 new people to the team; Jannis, Lofty and Krystine. They‚Äôll be helping us to improve the formal and FPGA tooling, and improve our documentation. If you don‚Äôt already follow us on twitter - we post as YosysHQ. Whitequark just had a great ‚Äòask me anything‚Äô on digital logic. As a small company, we really appreciate being recommended to people - please let us know if you have any leads! ","date":"2022-04-06T00:00:00Z","image":"http://blog.yosyshq.com/static-2022/YOS_horiz.png","permalink":"http://blog.yosyshq.com/p/tabby-cad-suite-version-20220406-released/","title":"Tabby CAD Suite version 20220406 released!"},{"content":"Yosys is probably best known for providing synthesis for FPGA targets, but it\u0026rsquo;s a very flexible tool capable of a lot more.\nOpenLane, SiliconCompiler and Coriolis2 are 3 examples of open source ASIC flows, which has been an active field of development over the last year.\nWe\u0026rsquo;re very happy to see our tools get used in the first Google sponsored tapeouts, helping to make the world\u0026rsquo;s first chips made with an open source PDK, and open source all the way down to the designs.\nIf you want to find out more about what happened in the world of open source silicon in 2021, you can see our CSO Matt Venn\u0026rsquo;s recent presentation for Hackaday Remoticon here:\n","date":"2022-02-28T11:23:54+01:00","permalink":"http://blog.yosyshq.com/p/open-source-silicon-with-yosys/","title":"Open Source Silicon with Yosys"},{"content":"Code: https://github.com/YosysHQ-Docs/Blog-Async-Load-FFs\n# Part 1: The Bad News We have recently added support for asynchronous load flip-flops to Yosys for a customer project. However, we consider this a problematic feature in a (System-)Verilog synthesis tool, and thus I‚Äôd like to take this opportunity to explain why one should avoid using asynchronous load flip-flops in new (System-)Verilog designs.\n# What are asynchronous load flip-flops An asynchronous load flip-flop is a type of flip-flop with asynchronous reset for which the reset value is not a compile-time / synthesis-time constant.\nreg async_load_ff_q; wire async_load_ff_reset_val = \u0026lt;dynamic_expression\u0026gt;; always_ff @(posedge clock, posedge load) if (load) async_load_ff_q \u0026lt;= async_load_ff_reset_val; else async_load_ff_q \u0026lt;= ...; This distinguishes them from the more common asynchronous set (reset) flip-flops, for which the reset value is a compile-time (synthesis-time) constant.\nreg async_reset_ff_q; localparam async_reset_ff_reset_val = \u0026lt;constant_expression\u0026gt;; always_ff @(posedge clock, posedge reset) if (reset) async_reset_ff_q \u0026lt;= async_reset_ff_reset_val; else async_reset_ff_q \u0026lt;= ...; IEEE Std 1364.1-2002, the IEEE Standard for Verilog Register Transfer Level Synthesis, does allow such asynchronous load flip-flops in synthesis, but states that the synthesis results will only match the behavior of the original Verilog code under certain conditions.\n# The problem with Verilog and asynchronous load flip-flops The key insight is that the way an asynchronous reset is modelled using Verilog always blocks is not sensitive to the data signals providing the asynchronous load value. Thus, if the data signals are changing while the asynchronous reset is active, the new data is not loaded into the flip-flop when neither clock nor the asynchronous reset is toggling.\nConsider the following SystemVerilog design (dut.sv):\nmodule dut ( input clk1, clk2, arst, output reg [7:0] cnt1, cnt2 ); always_ff @(posedge clk1 or posedge arst) if (arst) cnt1 \u0026lt;= 0; // constant expression (async reset) else cnt1 \u0026lt;= cnt1 + 7; always_ff @(posedge clk2 or posedge arst) if (arst) cnt2 \u0026lt;= cnt1; // dynamic expression (async load) else cnt2 \u0026lt;= cnt2 + 11; endmodule And the following test bench (tb.sv):\nmodule tb; reg clk1 = 0, clk2 = 0, arst = 0; wire [7:0] cnt1, cnt2; dut dut (clk1, clk2, arst, cnt1, cnt2); task do_clk1; clk1 = 1; #5; clk1 = 0; #5; endtask task do_clk2; clk2 = 1; #5; clk2 = 0; #5; endtask task do_arst; arst = 1; #5; arst = 0; #5; `ifdef DOUBLE_ARST arst = 1; #5; arst = 0; #5; `endif endtask initial begin #10; do_arst; $display(cnt1, cnt2); repeat (5) do_clk1; $display(cnt1, cnt2); do_arst; $display(cnt1, cnt2, \u0026#34; \u0026lt;--\u0026#34;); repeat (5) do_clk2; $display(cnt1, cnt2); do_arst; $display(cnt1, cnt2); end endmodule Running it without and with -DDOUBLE_ARST produces the following output:\n$ make run0 iverilog -g2012 -o sim0 -s tb tb.sv dut.sv ./sim0 0 x 35 x 0 35 \u0026lt;-- 0 90 0 0 $ make run1 iverilog -g2012 -o sim1 -s tb -DDOUBLE_ARST tb.sv dut.sv ./sim1 0 0 35 0 0 0 \u0026lt;-- 0 55 0 0 In the first case with a single pulse on arst, the second counter is reset to the non-zero value of the first counter from before the reset pulse.\nBut a real-world asynchronous load flip-flop would of course behave like a transparent latch while the reset pulse is high, propagating the new (zero) value of the first counter to the second counter register. But this only happens in simulation when we pulse the reset signal a second time.\nThis can lead to non-trivial simulation-synthesis mismatches that are hard to debug, and may result in a chip that does not function as expected.\nThus, asynchronous load flip-flops should be avoided in (System)Verilog designs, or at least it should be formally verified that the asynchronous load value of such a flip-flop can never change while the reset signal is active.\nThis is in line with IEEE Std 1364.1-2002 requirements for sequential logic verification:\nWhen asynchronous data is assigned, the asynchronous data shall not change during the period in which the asynchronous control (the condition under which the data is assigned) is active.\nIEEE Std 1364.1-2002, Section 4.2\nIt is worth noting that a similar problem exists with flip-flops that have both asynchronous set and reset: If both are asserted and then one is released after the other, the one that‚Äôs released later should take precedence over the one that‚Äôs released earlier. However, since the always block is not triggered by the falling edge of the set or reset signal, releasing just one of the two will have no effect on the flip-flop output. IEEE Std 1364.1-2002 also acknowledges this issue:\nThe problem occurs when both reset and preset are asserted at the same time and reset is removed first. When reset is removed (posedge rst_n), the always block is not activated. This means that the output will continue to drive the reset output to ‚Äò0‚Äô until the next rising clock edge. A real flip-flop of this type would immediately drive the output to ‚Äò1‚Äô because the set_n signal is an asynchronous preset. This potentially could cause a mismatch between pre-synthesis and post-synthesis simulations using this model.\nIEEE Std 1364.1-2002, Appendix B.6\n# Part 2: The Good News In this section we discuss different design methods that avoid the use of behavioral Verilog code to model asynchronous load FFs.\n# Instantiate (Vendor) Primitives The best and easiest way of dealing with this issue is to instantiate FF primitives directly. This can either be vendor cells, or a user-defined module for which we chose different implementations for simulation and synthesis, one with correct simulation behavior, and one that is synthesizable, respectively.\nThe new DUT would look something like this (dut_myff.sv):\nmodule dut ( input clk1, clk2, arst, output reg [7:0] cnt1, cnt2 ); myff ff1[7:0] (cnt1, cnt1 + 8\u0026#39;d 7, clk1, arst, 8\u0026#39;h 00), ff2[7:0] (cnt2, cnt2 + 8\u0026#39;d 11, clk2, arst, cnt1); endmodule When instantiating a Vendor primitive one should always double-check that the vendor simulation library does model asynchronous loads correctly, for example using the techniques described in the next two sections.\n# Simulation model using Verilog UDP Verilog UDP primitives can be used to correctly model the behavior of asynchronous load flip-flops. But UDPs are not synthesizable, so we need to also provide a synthesizable implementation of an asynchronous load flip-flop (myff_udp.sv):\n`ifdef SYNTHESIS module myff ( output reg q, input d, clk, arst, rval ); always @(posedge clk or posedge arst) if (arst) q \u0026lt;= rval; else q \u0026lt;= d; endmodule `else primitive myff (q, d, clk, arst, rval); input d, clk, arst, rval; reg q; output q; table // D C R V : Q : Q\u0026#39; ? ? 1 0 : ? : 0 ; // async reset ? ? 1 1 : ? : 1 ; // async set 0 p 0 ? : ? : 0 ; // posedge clock, d=0 1 p 0 ? : ? : 1 ; // posedge clock, d=1 ? n 0 ? : ? : - ; // negedge clock * ? ? ? : ? : - ; // any data edge ? ? * ? : ? : - ; // any arst edge ? ? ? * : ? : - ; // any rval edge endtable endprimitive `endif Running our test-bench now yields the expected result, even when we pulse the asynchronous load signal only once:\n$ make run2 iverilog -g2012 -o sim2 -s tb tb.sv dut_myff.sv myff_udp.sv ./sim2 0 0 35 0 0 0 \u0026lt;-- 0 55 0 0 # Simulation model using procedural assign and deassign Another approach is to ‚Äúfix up‚Äù the asynchronous load using procedural assign and deassign (myff_ada.sv):\nmodule myff ( output reg q, input d, clk, arst, rval ); always_ff @(posedge clk or posedge arst) if (arst) q \u0026lt;= rval; else q \u0026lt;= d; `ifndef SYNTHESIS always @(arst) if (arst) assign q = rval; else deassign q; `endif endmodule Running our test-bench on this version also yields the expected result:\niverilog -g2012 -o sim3 -s tb tb.sv dut_myff.sv myff_ada.sv ./sim3 0 0 35 0 0 0 \u0026lt;-- 0 55 0 0 Of course it‚Äôs also possible to use procedural assign and deassign directly in the design to ‚Äúfix up‚Äù the behavior of asynchronous load flip-flops (dut_ada.sv):\nmodule dut ( input clk1, clk2, arst, output reg [7:0] cnt1, cnt2 ); always_ff @(posedge clk1 or posedge arst) if (arst) cnt1 \u0026lt;= 0; else cnt1 \u0026lt;= cnt1 + 7; always_ff @(posedge clk2 or posedge arst) if (arst) cnt2 \u0026lt;= cnt1; else cnt2 \u0026lt;= cnt2 + 11; `ifndef SYNTHESIS always @(arst) if (arst) assign cnt2 = cnt1; else deassign cnt2; `endif endmodule However, sprinkling procedural assign and deassign statements and ifndef-SYNTHESIS-blocks all over the design is much more error prone than implementing this work-around only once in a custom cell type that can then be instantiated wherever needed.\n# The latch+flip-flop trick The following technique is used on some FPGA architectures to emulate asynchronous-load flip-flops using latches and asynchronous-reset flip-flops only. It can be used to completely avoid asynchronous-load FFs while preserving the semantic of such elements (myff_hack.sv):\nmodule myff ( output q, input d, clk, arst, rval ); // a latch to store the async-load value reg latched_rval; always @* if (arst) latched_rval = rval; // a regular FF to store the clocked data value reg q_without_reset; always @(posedge clk) q_without_reset \u0026lt;= d; // an asynchronous-reset flip-flop to remember last event reg last_event_was_clock; always @(posedge clk or posedge arst) if (arst) last_event_was_clock \u0026lt;= 0; else last_event_was_clock \u0026lt;= 1; // output either the latched reset value or clocked data value assign q = last_event_was_clock ? q_without_reset : latched_rval; endmodule Running our test-bench a last time gives the expected result for this solution as well:\niverilog -g2012 -o sim5 -s tb tb.sv dut_myff.sv myff_hack.sv ./sim5 0 0 35 0 0 0 \u0026lt;-- 0 55 0 0 This is a useful last resort solution for designs that absolutely require asynchronous-load flip-flop semantics, and where the risks associated with using different synthesis and simulation models for such a component are not acceptable.\n","date":"2021-11-30T00:00:00Z","image":"http://blog.yosyshq.com/static-2021/asyncff.png","permalink":"http://blog.yosyshq.com/p/async-load-ff/","title":"Why Asynchronous Load Flip-Flops Should Be Avoided"},{"content":"YosysHQ are pleased to announce a new pricing option for small companies with one full time engineer.\nFor just ‚Ç¨500 per month (excl. VAT), you can get our ‚ÄòSolo bundle‚Äô:\n2 nodes of TabbyCAD Suite, offering industry compatible language support and our formal verification tools and verification IP. Unlimited number of users/processes per node. (Up to 32 CPUs per node.) Not time limited, use in your continuous integration systems. Support that includes potential for custom work and access to our technical team. For two full time engineers, we have our ‚ÄòSolo bundle plus‚Äô which adds another 2 TabbyCAD nodes for an additional ‚Ç¨400 per month.\nWe also have competitive prices for larger teams.\nFor an evaluation license, or to discuss your requirements further please contact us at contact@yosyshq.com.\n","date":"2021-07-26T15:35:40+02:00","permalink":"http://blog.yosyshq.com/p/pricing-for-small-companies/","title":"New pricing for small companies"},{"content":"This Application Note was written with the intention of showing a brief introduction to SVA, and is definitely not a substitute for extensive training. To learn more about formal verification and SVA, it is recommended to book the course given by the FPV specialists at YosysHQ.\nA brief history of SystemVerilog Assertions SVA layers definition and examples Assertion types, sequential property operators A short description of liveness and safety properties Practical examples using the sequence builder module written by our CTO Claire Xen. https://yosyshq.readthedocs.io/projects/ap109\nFeel free to give us feedback and suggest new topics.\n","date":"2021-07-07T12:37:04+02:00","permalink":"http://blog.yosyshq.com/p/ap109/","title":"App Note 109"},{"content":"For a long time people have asked us for quality long form content that shows how to get the best from our formal tools.\nWe have started a series of app notes, with the first being about cover and witness for SVA properties. Otherwise known as \u0026lsquo;Am I testing what I think I\u0026rsquo;m testing\u0026rsquo;!\nWhat You will learn in this app note:\nDefault clocking and default disable declarations Sequences and cycle delays Overlapping and non-overlapping implication syntax and semantic Weak precondition cover and witness How to apply that to a practical HDL code example https://yosyshq.readthedocs.io/projects/ap120\nFeel free to give us feedback and suggest new topics.\n","date":"2021-05-20T14:04:45+02:00","permalink":"http://blog.yosyshq.com/p/ap120/","title":"App Note 120"},{"content":"YosysHQ.com is the new home for the team maintaining Yosys and the related Open Source EDA projects, and the commercial products and services we offer.\nOur team is led by N. Engelhardt as CEO, Claire Wolf as CTO, and Matt Venn as CSO. We are looking to work with more people, so feel free to contact us: contact@yosyshq.com\nTabby CAD Suite is a bundle of our well-known Open Source EDA software packages, combined with additional components that allow seamless integration of our tools in typical industrial digital design environments.\nWe also provide support and training for users of our Tabby CAD Suite package and for developers building their work on top of our open source projects.\nIn addition, we welcome opportunities to get involved with new projects large and small. We are looking to grow our collaborations with industry and academic partners on improving and expanding our synthesis, place and route, and formal verification flows.\nWe look forward to a positive relationship with the Open Source EDA community and external partners.\nMake sure you visit our website www.yosyshq.com and send us an email or tweet at us @YosysHQ to say hi!\n","date":"2021-02-08T00:00:00Z","permalink":"http://blog.yosyshq.com/p/hello/","title":"Hello World!"}]